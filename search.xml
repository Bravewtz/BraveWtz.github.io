<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[18包含min函数的栈]]></title>
    <url>%2F2020%2F01%2F14%2F18%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目：定义栈的数据结构，请在类型中实现一个能够得到栈最小元素的min函数。 分析：使用两个stack，一个为数据栈，另一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。 举个例子：入栈的时候：首先往空的数据栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来往数据栈里压入数字4。由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。 出栈的时候：当数据栈和辅助栈的栈顶元素相同的时候，辅助栈的栈顶元素出栈。否则，数据栈的栈顶元素出栈。 获得栈顶元素的时候：直接返回数据栈的栈顶元素。 栈最小元素：直接返回辅助栈的栈顶元素。 C++代码： 123456789101112131415161718192021222324252627class Solution &#123;public: void push(int value) &#123; Data.push(value); if(Min.empty())&#123; Min.push(value); &#125; if(Min.top() &gt; value)&#123; Min.push(value); &#125; &#125; void pop() &#123; if(Data.top() == Min.top())&#123; Min.pop(); &#125; Data.pop(); &#125; int top() &#123; return Data.top(); &#125; int min() &#123; return Min.top(); &#125;private: stack&lt;int&gt; Data; //数据栈 stack&lt;int&gt; Min; //最小栈&#125;; Python代码： 123456789101112131415161718192021222324252627282930class Solution: def __init__(self): self.Data = [] self.Min = [] def push(self, node): # write code here self.Data.append(node) if self.Min: if self.Min[-1] &gt; node: self.Min.append(node) else: self.Min.append(self.Min[-1]) #保证Min栈的栈顶一直指向最小的数字，即使出现重复输入也不会出错 else: self.Min.append(node) def pop(self): # write code here if self.Data == []: return None self.Min.pop() return self.Data.pop() def top(self): # write code here if self.Data == []: return None return self.Data[-1] def min(self): # write code here if self.Min == []: return None return self.Min[-1]]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17顺时针打印矩阵]]></title>
    <url>%2F2020%2F01%2F14%2F17%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：则依次打印出数组：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10。 分析：将结果存入vector数组，从左到右，再从上到下，再从右到左，最后从下到上遍历。 C++代码： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; int rows = matrix.size(); //行数 int cols = matrix[0].size(); //列数 vector&lt;int&gt; result; if(rows == 0 &amp;&amp; cols == 0)&#123; return result; &#125; int left = 0, right = cols - 1, top = 0, bottom = rows - 1; while(left &lt;= right &amp;&amp; top &lt;= bottom)&#123; //从左到右 for(int i = left; i &lt;= right; ++i)&#123; result.push_back(matrix[top][i]); &#125; //从上到下 for(int i = top + 1; i &lt;= bottom; ++i)&#123; result.push_back(matrix[i][right]); &#125; //从右到左 if(top != bottom)&#123; for(int i = right - 1; i &gt;= left; --i)&#123; result.push_back(matrix[bottom][i]); &#125; &#125; //从下到上 if(left != right)&#123; for(int i = bottom - 1; i &gt; top; --i)&#123; result.push_back(matrix[i][left]); &#125; &#125; left++, top++, right--, bottom--; &#125; return result; &#125;&#125;; Python代码： 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here rows = len(matrix) cols = len(matrix[0]) result = [] if rows == 0 and cols == 0: return result left, right, top, buttom = 0, cols - 1, 0, rows - 1 while left &lt;= right and top &lt;= buttom: for i in range(left, right+1): result.append(matrix[top][i]) for i in range(top+1, buttom+1): result.append(matrix[i][right]) if top != buttom: for i in range(left, right)[::-1]: result.append(matrix[buttom][i]) if left != right: for i in range(top+1, buttom)[::-1]: result.append(matrix[i][left]) left += 1 top += 1 right -= 1 buttom -= 1 return result]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16二叉树的镜像]]></title>
    <url>%2F2020%2F01%2F11%2F16%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[题目：操作给定的二叉树，将其变换为源二叉树的镜像。 如下图所示： 分析：先交换根节点的两个子结点之后，我们注意到值为10、6的结点的子结点仍然保持不变，因此我们还需要交换这两个结点的左右子结点。做完这两次交换之后，我们已经遍历完所有的非叶结点。此时变换之后的树刚好就是原始树的镜像。交换示意图如下所示： C++代码： 12345678910111213141516171819202122232425262728293031/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if((pRoot == NULL) || (pRoot-&gt;left == NULL &amp;&amp; pRoot-&gt;right == NULL))&#123; return; &#125; //交换根节点的左右结点 TreeNode *pTemp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = pTemp; //递归左子树 if(pRoot-&gt;left)&#123; Mirror(pRoot-&gt;left); &#125; //递归右子树 if(pRoot-&gt;right)&#123; Mirror(pRoot-&gt;right); &#125; &#125;&#125;; Python代码： 1234567891011121314151617181920# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if (root == None or (root.left == None and root.right == None)): return None tmp = root.left root.left = root.right root.right = tmp if root.left: self.Mirror(root.left) if root.right: self.Mirror(root.right)]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15树的子结构]]></title>
    <url>%2F2020%2F01%2F08%2F15%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目：输入两颗二叉树A，B，判断B是不是A的子结构。（PS：我们约定空树不是任意一个树的子结构）。 分析：要查找树A中是否存在和树B结构一样的子树，我们可以分为两步：第一步在树A中找到和B的根结点的值一样的结点R，第二步再判断树A中以R为根节点的子树是不是包含和树B一样的结构。这里使用递归的方法即可。 C++代码： 1234567891011121314151617181920212223242526272829303132333435/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; bool result = false; if(pRoot1 != NULL &amp;&amp; pRoot2 != NULL)&#123; if(pRoot1-&gt;val == pRoot2-&gt;val)&#123; result = DoesTree1HasTree2(pRoot1, pRoot2); &#125; if(!result)&#123; result = HasSubtree(pRoot1-&gt;left, pRoot2); &#125; if(!result)&#123; result = HasSubtree(pRoot1-&gt;right, pRoot2); &#125; &#125; return result; &#125;private: bool DoesTree1HasTree2(TreeNode* pRoot1, TreeNode* pRoot2)&#123; if(pRoot2 == NULL) return true; if(pRoot1 == NULL) return false; if(pRoot1-&gt;val != pRoot2-&gt;val) return false; return DoesTree1HasTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; DoesTree1HasTree2(pRoot1-&gt;right, pRoot2-&gt;right); &#125;&#125;; Python代码： 123456789101112131415161718# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False return self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) or self.is_subtree(pRoot1, pRoot2) def is_subtree(self, A, B): if not B: return True if not A or A.val != B.val: return False return self.is_subtree(A.left, B.left) and self.is_subtree(A.right, B.right)]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14合并两个排序的链表]]></title>
    <url>%2F2020%2F01%2F08%2F14%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 分析：先判断输入的链表是否为空的指针。如果第一个链表为空，则直接返回第二个链表；如果第二个链表为空，则直接返回第一个链表。如果两个链表都是空链表，合并的结果是得到一个空链表。两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表中的值小，即赋给合并链表指针即可。使用递归就可以轻松实现。 C++代码： 123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; if(pHead1==NULL) return pHead2; if(pHead2==NULL) return pHead1; ListNode* pMergeHead=NULL; if(pHead1-&gt;val&lt;pHead2-&gt;val)&#123; pMergeHead=pHead1; pMergeHead-&gt;next=Merge(pHead1-&gt;next,pHead2); &#125; else&#123; pMergeHead=pHead2; pMergeHead-&gt;next=Merge(pHead2-&gt;next,pHead1); &#125; return pMergeHead; &#125;&#125;; Python代码： 123456789101112131415161718192021# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here if not pHead1: return pHead2 if not pHead2: return pHead1 pMergeHead = None if pHead1.val&lt;pHead2.val: pMergeHead=pHead1 pMergeHead.next=self.Merge(pHead1.next,pHead2) else: pMergeHead=pHead2 pMergeHead.next=self.Merge(pHead2.next,pHead1) return pMergeHead]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13反转链表]]></title>
    <url>%2F2020%2F01%2F07%2F13%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目：输入一个链表，反转链表后，输出链表的所有元素。 分析：这个很简单，我们使用三个指针，分别指向当前遍历到的结点、它的前一个结点以及后一个结点。在遍历的时候，做当前结点的尾结点和前一个结点的替换。 C++代码： 1234567891011121314151617181920212223242526/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; ListNode* pReversedHead = NULL; ListNode* pNode = pHead; ListNode* pPrev = NULL; while(pNode != NULL)&#123; ListNode* pNext = pNode-&gt;next; if(pNext == NULL)&#123; pReversedHead = pNode; &#125; pNode-&gt;next = pPrev; pPrev = pNode; pNode = pNext; &#125; return pReversedHead; &#125;&#125;; Python代码： 123456789101112131415161718# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead last = None while pHead: tmp = pHead.next pHead.next = last last = pHead pHead = tmp return last]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12链表中倒数第K个结点]]></title>
    <url>%2F2020%2F01%2F07%2F12%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：输入一个链表，输出该链表中倒数第k个结点。 分析：我们可以定义两个指针。第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k个结点。效果示意图，以链表总共6个结点，求倒数第3个结点为例：除此之外，要注意代码的鲁棒性。需要判断传入参数合法性问题。 C++代码： 123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; if(pListHead==NULL || k==0) return NULL; pListHead* pAHead=pListHead; pListHead* pBHead=pListHead; for(unsigned int i=0;i&lt;k-1;i++)&#123; if(pAHead-&gt;next!=NULL)&#123; pAHead=pAHead-&gt;next; &#125; else return NULL; &#125; while(pAHead-&gt;next!=NULL)&#123; pAHead=pAHead-&gt;next; pBHead=pBHead-&gt;next; &#125; return PBHead; &#125;&#125;; Python代码： 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindKthToTail(self, head, k): # write code here if head == None or k == 0: return None pAHead = head pBHead = head for i in range(k-1): if pAHead.next == None: return None else: pAHead=pAHead.next while pAHead.next != None: pAHead = pAHead.next pBHead = pBHead.next return pBHead 下面的做法用列表，开辟新空间了，不太好。 Python代码： 12345678910111213141516# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindKthToTail(self, head, k): # write code here l=[] while head: l.append(head) head=head.next if len(l)&lt;k or k&lt;1: return None return l[-k]]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11调整数组顺序使奇数位于偶数前面]]></title>
    <url>%2F2020%2F01%2F06%2F11%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 分析：创建双向队列，遍历数组，奇数前插入，偶数后插入。最后使用assign方法实现不同容器但相容的类型赋值。 C++代码： 123456789101112class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; deque&lt;int&gt; dq; int _size=array.size(); for(int i=0;i&lt;_size;i++)&#123; if(array[_size-i-1]%2==1) dq.push_front(array[_size-i-1]); if(array[i]%2==0) dq.push_back(array[i]); &#125; array.assign(dq.begin(),dq.end()); &#125;&#125;; Python代码： 12345678910111213# -*- coding:utf-8 -*-from collections import dequeclass Solution: def reOrderArray(self, array): # write code here odd=deque() l = len(array) for i in range(l): if array[l-i-1]%2==1: odd.appendleft(array[l-i-1]) if array[i]%2==0: odd.append(array[i]) return list(odd)]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10数值的整数次方]]></title>
    <url>%2F2020%2F01%2F06%2F10%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 分析：当指数为负数的时候，可以先对指数求绝对值，然后算出次方的结果之后再取倒数。如果底数为0，则直接返回0。此时的次方在数学上是没有意义的。 除此之外，我们要注意：由于计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它们相等。 在计算次方的时候，除了简单的遍历，我们可以使用如下公式进行计算，来减少计算量： C++代码： 1234567891011121314151617181920212223242526class Solution &#123;public: double Power(double base, int exponent) &#123; if(_equal(base,0.0)) return 0; int abs_exponent=abs(exponent); double result=PowerExponent(base,abs_exponent); if(exponent&lt;0) result=1.0/result; return result; &#125; private: bool _equal(double num1,double num2)&#123; if(num1-num2 &gt; -0.0000001 &amp;&amp; num1-num2 &lt; 0.0000001 )return true; else return false; &#125; double PowerExponent(double base,int exponent)&#123; if(exponent==0) return 1; if(exponent==1) return base; double _result=PowerExponent(base,exponent&gt;&gt;1); _result*=_result; if(exponent % 2==1) _result*=base; return _result; &#125;&#125;; Python代码： 123456789101112131415# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here flag=0 result=1 if base==0: return False if exponent&lt;0: flag=1 for i in range(abs(exponent)): result*=base if flag==1: result=1/result return result]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09二进制中1的个数]]></title>
    <url>%2F2020%2F01%2F05%2F09%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 分析：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 C++代码： 1234567891011class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; while(n)&#123; ++count; n = (n - 1) &amp; n; &#125; return count; &#125;&#125;; 在Python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机是以补码存在的，往右移，符号位不变，符号位1往右移，最终可能会出现全1的情况，导致死循环。与0xffffffff相与，就可以消除负数的影响。 Python代码：1234567891011# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here count = 0 if n&lt;0: n = n &amp; 0xffffffff while n: count += 1 n = n &amp; (n-1) return count 或者可以使用一个更直观的方法，直接位移即可，代码如下： 12345# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here return sum([(n &gt;&gt; i &amp; 1) for i in range(0,32)])]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08矩形覆盖]]></title>
    <url>%2F2020%2F01%2F05%2F08%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[题目：我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 分析：以2x8的矩形为例。示意图如下：我们先把2x8的覆盖方法记为f(8)。用第一个1x2小矩阵覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2x7的区域，这种情况下的覆盖方法记为f(7)。接下来考虑横着放的情况。当1x2的小矩形横着放在左上角的时候，左下角和横着放一个1x2的小矩形，而在右边还剩下2x6的区域，这种情况下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)。此时我们可以看出，这仍然是斐波那契数列。 C++代码： 123456789101112131415class Solution &#123;public: int rectCover(int number) &#123; if(number &lt;= 2)&#123; return number; &#125; int first = 1, second = 2, third = 0; for(int i = 3; i &lt;= number; i++)&#123; third = first + second; first = second; second = third; &#125; return third; &#125;&#125;; Python代码： 123456789101112# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number &lt;= 2: return number first, second, third = 1, 2, 0 for i in range(3, number+1): third = first + second first = second second = third return third]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07斐波那契数列]]></title>
    <url>%2F2020%2F01%2F04%2F07%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39） 斐波那契数列公式为： 分析：这道题递归很好写，但是存在很严重的效率问题。我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，我们不难发现在这棵树中有很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。 所以，使用简单的循环方法来实现。 C++代码： 1234567891011121314class Solution &#123;public: int Fibonacci(int n) &#123; if(n==0) return 0; if(n==1) return 1; int first=0,second=1,third=0; for(int i=2;i&lt;=n;i++)&#123; third=first+second; first=second; second=third; &#125; return third; &#125;&#125;; Python代码： 123456789101112# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n &lt;= 1: return n first, second, third = 0, 1, 0 for i in range(2, n+1): third = first + second first = second second = third return third]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06旋转数组的最小数字]]></title>
    <url>%2F2020%2F01%2F02%2F06%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 分析：我们注意到旋转之后的数组实际上可以划分为两个排序的字数组，而且前面的字数组的元素大于或者等于后面字数组的元素。我们还注意到最小的元素刚好是这两个字数组的分界线。在排序的数组中可以用二分查找实现O(logn)的查找。本题给出的数组在一定程度上是排序的，因此我们可以试着用二分查找法的思路来寻找这个最小的元素。 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。接着我们可以找到数组中间的元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时最小元素应该位于该中间元素之后，然后我们把第一个指针指向该中间元素，移动之后第一个指针仍然位于前面的递增子数组中。同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时最小元素应该位于该中间元素之前，然后我们把第二个指针指向该中间元素，移动之后第二个指针仍然位于后面的递增子数组中。第一个指针总是指向前面递增数组的元素，第二个指针总是指向后面递增数组的元素。最终它们会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。特殊情况： 如果把排序数组的0个元素搬到最后面，这仍然是旋转数组，我们的代码需要支持这种情况。如果发现数组中的一个数字小于最后一个数字，就可以直接返回第一个数字了。 下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1是数以前面的递增子数组还是后面的递增子数组。正样的话，我们只能进行顺序查找。 C++代码：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int _size=rotateArray.size(); if(_size==0) return 0; int left=0; int right=_size-1; int mid=0; while(rotateArray[left]&gt;=rotateArray[right])&#123; if(right-left==1)&#123; mid=right; break; &#125; mid=left+(right-left)/2; //计算中间指针位置 //特殊情况：如果无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找 if(rotateArray[left]==rotateArray[right]&amp;&amp;rotateArray[mid]==rotateArray[right])&#123; return MinInOrder(rotateArray,left,right); &#125; //中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面 if(rotateArray[mid]&gt;=rotateArray[left]) left=mid; //中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面 else right=mid; &#125; return rotateArray[mid]; &#125;private: //寻找最小顺序 int MinInOrder(vector&lt;int&gt; &amp;num,int left,int right)&#123; int res=num[left]; for(int i=left+1;i&lt;right;i++)&#123; if(num[i]&lt;res) res=num[i]; &#125; return res; &#125;&#125;; Python代码：12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int size = rotateArray.size(); //数组长度 if(size == 0)&#123; return 0; &#125; int left = 0; //左指针 int right = size - 1; //右指针 int mid = 0; //中间指针 while(rotateArray[left] &gt;= rotateArray[right])&#123; //确保旋转 if(right - left == 1)&#123; //左右指针相邻 mid = right; break; &#125; mid = left + (right - left) / 2; //计算中间指针位置 //特殊情况：如果无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找 if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[mid] == rotateArray[left])&#123; return MinInOrder(rotateArray, left, right); &#125; //中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面 if(rotateArray[mid] &gt;= rotateArray[left])&#123; left = mid; &#125; //中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面 else&#123; right = mid; &#125; &#125; return rotateArray[mid]; &#125;private: //顺序寻找最小值 int MinInOrder(vector&lt;int&gt; &amp;num, int left, int right)&#123; int result = num[left]; for(int i = left + 1; i &lt; right; i++)&#123; if(num[i] &lt; result)&#123; result = num[i]; &#125; &#125; return result; &#125;&#125;;]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树基础]]></title>
    <url>%2F2019%2F12%2F31%2F%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[（一）：决策树 决策树是什么？决策树(decision tree)是一种基本的分类与回归方法。举个通俗易懂的例子，如下图所示的流程图就是一个决策树，长方形代表判断模块(decision block)，椭圆形成代表终止模块(terminating block)，表示已经得出结论，可以终止运行。从判断模块引出的左右箭头称作为分支(branch)，它可以达到另一个判断模块或者终止模块。我们还可以这样理解，分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点(node)和有向边(directed edge)组成。结点有两种类型：内部结点(internal node)和叶结点(leaf node)。内部结点表示一个特征或属性，叶结点表示一个类。蒙圈没？？如下图所示的决策树，长方形和椭圆形都是结点。长方形的结点属于内部结点，椭圆形的结点属于叶结点，从结点引出的左右箭头就是有向边。而最上面的结点就是决策树的根结点(root node)。这样，结点说法就与模块说法对应上了，理解就好。 我们回到这个流程图，对，你没看错，这就是一个假想的相亲对象分类系统。它首先检测相亲对方是否有房。如果有房，则对于这个相亲对象可以考虑进一步接触。如果没有房，则观察相亲对象是否有上进心，如果没有，直接Say Goodbye，此时可以说：”你人很好，但是我们不合适。”如果有，则可以把这个相亲对象列入候选名单，好听点叫候选名单，有点瑕疵地讲，那就是备胎。 不过这只是个简单的相亲对象分类系统，只是做了简单的分类。真实情况可能要复杂得多，考虑因素也可以是五花八门。脾气好吗？会做饭吗？愿意做家务吗？家里几个孩子？父母是干什么的？天啊，我不想再说下去了，想想都可怕。 我们可以把决策树看成一个if-then规则的集合，将决策树转换成if-then规则的过程是这样的：由决策树的根结点(root node)到叶结点(leaf node)的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。决策树的路径或其对应的if-then规则集合具有一个重要的性质：互斥并且完备。这就是说，每一个实例都被一条路径或一条规则所覆盖，而且只被一条路径或一条规则所覆盖。这里所覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。 使用决策树做预测需要以下过程： 收集数据：可以使用任何方法。比如想构建一个相亲系统，我们可以从媒婆那里，或者通过采访相亲对象获取数据。根据他们考虑的因素和最终的选择结果，就可以得到一些供我们利用的数据了。 准备数据：收集完的数据，我们要进行整理，将这些所有收集的信息按照一定规则整理出来，并排版，方便我们进行后续处理。 分析数据：可以使用任何方法，决策树构造完成之后，我们可以检查决策树图形是否符合预期。 训练算法：这个过程也就是构造决策树，同样也可以说是决策树学习，就是构造一个决策树的数据结构。 测试算法：使用经验树计算错误率。当错误率达到了可接收范围，这个决策树就可以投放使用了。 使用算法：此步骤可以使用适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。（二）：决策树的构建的准备工作 使用决策树做预测的每一步骤都很重要，数据收集不到位，将会导致没有足够的特征让我们构建错误率低的决策树。数据特征充足，但是不知道用哪些特征好，将会导致无法构建出分类效果好的决策树模型。从算法方面看，决策树的构建是我们的核心内容。决策树要如何构建呢？通常，这一过程可以概括为3个步骤：特征选择、决策树的生成和决策树的修剪。 特征选择 特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率，如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是没有分类能力的。经验上扔掉这样的特征对决策树学习的精度影响不大。通常特征选择的标准是信息增益(information gain)或信息增益比，为了简单，本文使用信息增益作为选择特征的标准。那么，什么是信息增益？在讲解信息增益之前，让我们看一组实例，贷款申请样本数据表。 希望通过所给的训练数据学习一个贷款申请的决策树，用于对未来的贷款申请进行分类，即当新的客户提出贷款申请时，根据申请人的特征利用决策树决定是否批准贷款申请。特征选择就是决定用哪个特征来划分特征空间。比如，我们通过上述数据表得到两个可能的决策树，分别由两个不同特征的根结点构成。图(a)所示的根结点的特征是年龄，有3个取值，对应于不同的取值有不同的子结点。图(b)所示的根节点的特征是工作，有2个取值，对应于不同的取值有不同的子结点。两个决策树都可以从此延续下去。问题是：究竟选择哪个特征更好些？这就要求确定选择特征的准则。直观上，如果一个特征具有更好的分类能力，或者说，按照这一特征将训练数据集分割成子集，使得各个子集在当前条件下有最好的分类，那么就更应该选择这个特征。信息增益就能够很好地表示这一直观的准则。什么是信息增益呢？在划分数据集之后信息发生的变化称为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。（1）香农熵在可以评测哪个数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。集合信息的度量方式称为香农熵或者简称为熵(entropy)，这个名字来源于信息论之父克劳德·香农。如果看不明白什么是信息增益和熵，请不要着急，因为他们自诞生的那一天起，就注定会令世人十分费解。克劳德·香农写完信息论之后，约翰·冯·诺依曼建议使用”熵”这个术语，因为大家都不知道它是什么意思。熵定义为信息的期望值。在信息论与概率统计中，熵是表示随机变量不确定性的度量。如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为 ：其中p(xi)是选择该分类的概率。有人可能会问，信息为啥这样定义啊？答曰：前辈得出的结论。这就跟1+1等于2一样，记住并且会用即可。上述式中的对数以2为底，也可以e为底(自然对数)。通过上式，我们可以得到所有类别的信息。为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值(数学期望)，通过下面的公式得到：期中n是分类的数目。熵越大，随机变量的不确定性就越大。当熵中的概率由数据估计(特别是最大似然估计)得到时，所对应的熵称为经验熵(empirical entropy)。什么叫由数据估计？比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。我们定义贷款申请样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)，|D|表示其样本容量，及样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ：根据此公式计算经验熵H(D)，分析贷款申请样本数据表中的数据。最终分类结果只有两类，即放贷和不放贷。根据表中的数据统计可知，在15个数据中，9个数据的结果为放贷，6个数据的结果为不放贷。所以数据集D的经验熵H(D)为：经过计算可知，数据集D的经验熵H(D)的值为0.971。（2）编写代码计算经验熵在编写代码之前，我们先对数据集进行属性标注。年龄：0代表青年，1代表中年，2代表老年；有工作：0代表否，1代表是；有自己的房子：0代表否，1代表是；信贷情况：0代表一般，1代表好，2代表非常好；类别(是否给贷款)：no代表否，yes代表是。确定这些之后，我们就可以创建数据集，并计算经验熵了，代码编写如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding: UTF-8 -*-from math import log"""函数说明:创建测试数据集Parameters: 无Returns: dataSet - 数据集 labels - 分类属性Modify: 2019-12-30"""def createDataSet(): dataSet = [[0, 0, 0, 0, 'no'], #数据集 [0, 0, 0, 1, 'no'], [0, 1, 0, 1, 'yes'], [0, 1, 1, 0, 'yes'], [0, 0, 0, 0, 'no'], [1, 0, 0, 0, 'no'], [1, 0, 0, 1, 'no'], [1, 1, 1, 1, 'yes'], [1, 0, 1, 2, 'yes'], [1, 0, 1, 2, 'yes'], [2, 0, 1, 2, 'yes'], [2, 0, 1, 1, 'yes'], [2, 1, 0, 1, 'yes'], [2, 1, 0, 2, 'yes'], [2, 0, 0, 0, 'no']] labels = ['不放贷', '放贷'] #分类属性 return dataSet, labels #返回数据集和分类属性"""函数说明:计算给定数据集的经验熵(香农熵)Parameters: dataSet - 数据集Returns: shannonEnt - 经验熵(香农熵)Modify: 2019-12-30"""def calShannonEnt(datatSet): numEntires = len(dataSet) #返回数据集的行数 labelCounts = &#123;&#125; #保存每个标签(Label)出现次数的字典 for featVec in dataSet: #对每组特征向量进行统计 currentLabel = featVec[-1] #提取标签(Label)信息 if currentLabel not in labelCounts.keys(): #如果标签(Label)没有放入统计次数的字典,添加进去 labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 #Label计数 shannonEnt = 0.0 #经验熵(香农熵) for key in labelCounts: #计算香农熵 prob = float(labelCounts[key])/numEntires #选择该标签(Label)的概率 shannonEnt -= prob*log(prob,2) #利用公式计算 return shannonEnt #返回经验熵(香农熵)if __name__ == '__main__': dataSet,features = createDataSet() print(dataSet) print(features) print("经验熵（香农熵）为： %s" % calShannonEnt(dataSet)) （3） 信息增益在上面，我们已经说过，如何选择特征，需要看信息增益。也就是说，信息增益是相对于特征而言的，信息增益越大，特征对最终的分类结果影响也就越大，我们就应该选择对最终分类结果影响最大的那个特征作为我们的分类特征。在讲解信息增益定义之前，我们还需要明确一个概念，条件熵。熵我们知道是什么，条件熵又是个什么鬼？条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性，随机变量X给定的条件下随机变量Y的条件熵(conditional entropy)H(Y|X)，定义为X给定条件下Y的条件概率分布的熵对X的数学期望：同理，当条件熵中的概率由数据估计(特别是极大似然估计)得到时，所对应的条件熵称为条件经验熵(empirical conditional entropy)。明确了条件熵和经验条件熵的概念。接下来，让我们说说信息增益。前面也提到了，信息增益是相对于特征而言的。所以，特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即：一般地，熵H(D)与条件熵H(D|A)之差称为互信息(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数。于是经验条件熵的公式可以些为：以贷款申请样本数据表为例进行说明。看下年龄这一列的数据，也就是特征A1，一共有三个类别，分别是：青年、中年和老年。我们只看年龄是青年的数据，年龄是青年的数据一共有5个，所以年龄是青年的数据在训练数据集出现的概率是十五分之五，也就是三分之一。同理，年龄是中年和老年的数据在训练数据集出现的概率也都是三分之一。现在我们只看年龄是青年的数据的最终得到贷款的概率为五分之二，因为在五个数据中，只有两个数据显示拿到了最终的贷款，同理，年龄是中年和老年的数据最终得到贷款的概率分别为五分之三、五分之四。所以计算年龄的信息增益，过程如下：同理，计算其余特征的信息增益g(D,A2)、g(D,A3)和g(D,A4)。分别为：最后，比较特征的信息增益，由于特征A3(有自己的房子)的信息增益值最大，所以选择A3作为最优特征。4） 编写代码计算信息增益我们已经学会了通过公式计算信息增益，接下来编写代码，计算信息增益。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# -*- coding: UTF-8 -*-from math import log"""函数说明:计算给定数据集的经验熵(香农熵)Parameters: dataSet - 数据集Returns: shannonEnt - 经验熵(香农熵)Modify: 2019-12-30"""def calcShannonEnt(dataSet): numEntires = len(dataSet) #返回数据集的行数 labelCounts = &#123;&#125; #保存每个标签(Label)出现次数的字典 for featVec in dataSet: #对每组特征向量进行统计 currentLabel = featVec[-1] #提取标签(Label)信息 if currentLabel not in labelCounts.keys(): #如果标签(Label)没有放入统计次数的字典,添加进去 labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 #Label计数 shannonEnt = 0.0 #经验熵(香农熵) for key in labelCounts: #计算香农熵 prob = float(labelCounts[key]) / numEntires #选择该标签(Label)的概率 shannonEnt -= prob * log(prob, 2) #利用公式计算 return shannonEnt #返回经验熵(香农熵)"""函数说明:创建测试数据集Parameters: 无Returns: dataSet - 数据集 labels - 分类属性Modify: 2019-12-30"""def createDataSet(): dataSet = [[0, 0, 0, 0, 'no'], #数据集 [0, 0, 0, 1, 'no'], [0, 1, 0, 1, 'yes'], [0, 1, 1, 0, 'yes'], [0, 0, 0, 0, 'no'], [1, 0, 0, 0, 'no'], [1, 0, 0, 1, 'no'], [1, 1, 1, 1, 'yes'], [1, 0, 1, 2, 'yes'], [1, 0, 1, 2, 'yes'], [2, 0, 1, 2, 'yes'], [2, 0, 1, 1, 'yes'], [2, 1, 0, 1, 'yes'], [2, 1, 0, 2, 'yes'], [2, 0, 0, 0, 'no']] labels = ['不放贷', '放贷'] #分类属性 return dataSet, labels #返回数据集和分类属性"""函数说明:按照给定特征划分数据集Parameters: dataSet - 待划分的数据集 axis - 划分数据集的特征 value - 需要返回的特征的值Returns: 无Modify: 2019-12-30"""def splitDataSet(dataSet, axis, value): retDataSet = [] #创建返回的数据集列表 for featVec in dataSet: #遍历数据集 if featVec[axis] == value: reducedFeatVec = featVec[:axis] #去掉axis特征 reducedFeatVec.extend(featVec[axis+1:]) #将符合条件的添加到返回的数据集 retDataSet.append(reducedFeatVec) return retDataSet #返回划分后的数据集"""函数说明:选择最优特征Parameters: dataSet - 数据集Returns: bestFeature - 信息增益最大的(最优)特征的索引值Modify: 2019-12-30"""def chooseBestFeatureToSplit(dataSet): numFeatures = len(dataSet[0]) - 1 #特征数量 baseEntropy = calcShannonEnt(dataSet) #计算数据集的香农熵 bestInfoGain = 0.0 #信息增益 bestFeature = -1 #最优特征的索引值 for i in range(numFeatures): #遍历所有特征 #获取dataSet的第i个所有特征 featList = [example[i] for example in dataSet] uniqueVals = set(featList) #创建set集合&#123;&#125;,元素不可重复 newEntropy = 0.0 #经验条件熵 for value in uniqueVals: #计算信息增益 subDataSet = splitDataSet(dataSet, i, value) #subDataSet划分后的子集 prob = len(subDataSet) / float(len(dataSet)) #计算子集的概率 newEntropy += prob * calcShannonEnt(subDataSet) #根据公式计算经验条件熵 infoGain = baseEntropy - newEntropy #信息增益 print("第%d个特征的增益为%.3f" % (i, infoGain)) #打印每个特征的信息增益 if (infoGain &gt; bestInfoGain): #计算信息增益 bestInfoGain = infoGain #更新信息增益，找到最大的信息增益 bestFeature = i #记录信息增益最大的特征的索引值 return bestFeature #返回信息增益最大的特征的索引值if __name__ == '__main__': dataSet, features = createDataSet() print("最优特征索引值:" + str(chooseBestFeatureToSplit(dataSet))) splitDataSet函数是用来选择各个特征的子集的，比如选择年龄(第0个特征)的青年(用0代表)的自己，我们可以调用splitDataSet(dataSet,0,0)这样返回的子集就是年龄为青年的5个数据集。chooseBestFeatureToSplit是选择选择最优特征的函数。运行代码结果如下：对比我们自己计算的结果，发现结果完全正确！最优特征的索引值为2，也就是特征A3(有自己的房子)。2、决策树生成和修剪我们已经学习了从数据集构造决策树算法所需要的子功能模块，包括经验熵的计算和最优特征的选择，其工作原理如下：得到原始数据集，然后基于最好的属性值划分数据集，由于特征值可能多于两个，因此可能存在大于两个分支的数据集划分。第一次划分之后，数据集被向下传递到树的分支的下一个结点。在这个结点上，我们可以再次划分数据。因此我们可以采用递归的原则处理数据集。构建决策树的算法有很多，比如C4.5、ID3和CART，这些算法在运行时并不总是在每次划分数据分组时都会消耗特征。由于特征数目并不是每次划分数据分组时都减少，因此这些算法在实际使用时可能引起一定的问题。目前我们并不需要考虑这个问题，只需要在算法开始运行前计算列的数目，查看算法是否使用了所有属性即可。决策树生成算法递归地产生决策树，直到不能继续下去未为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05用两个栈实现队列]]></title>
    <url>%2F2019%2F12%2F31%2F05%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 分析：创建两个栈stack1和stack2，使用两个“先进后出”的栈实现一个“先进先出”的队列。我们通过一个具体的例子分析往该队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空。再压入两个元素b和c，还是插入到stack1中，此时stack1的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的。 这个时候我们试着从队列中删除一个元素。按照先入先出的规则，由于a比b、c先插入队列中，最先删除的元素应该是a。元素a存储在stack1中，但并不在栈顶，因此不能直接进行删除操作。注意stack2我们一直没有使用过，现在是让stack2发挥作用的时候了。如果我们把stack1中的元素逐个弹出压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。因此经过3次弹出stack1和要入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{b,a}，其中b在栈顶。 因此我们的思路是：当stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压倒stack1的栈底，经过弹出和压入之后就处于stack2的栈顶，有可以直接弹出。如果有新元素d插入，我们直接把它压入stack1即可。流程示意图： c++代码： 123456789101112131415161718192021222324class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; if(stack2.empty())&#123; while(stack1.size()&gt;0)&#123; int data=stack1.top(); stack1.pop(); stack2.push(data); &#125; &#125; int pop_element=stack2.top(); stack2.pop(); return pop_element; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; Python代码： 1234567891011121314# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if len(self.stack2) == 0: while len(self.stack1) &gt; 0: self.stack2.append(self.stack1.pop()) return self.stack2.pop()]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04重建二叉树]]></title>
    <url>%2F2019%2F12%2F31%2F04%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 分析：通常树有如下几种遍历方式：前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。本题为前序遍历和中序遍历，最少需要两种遍历方式，才能重建二叉树。前序遍历序列中，第一个数字总是树的根结点的值。在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。剩下的我们可以递归来实现，具体如图： c++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; if(pre.size()==0)return NULL; //依次前序遍历左子树，前序遍历右子树，中序遍历左子树，中序遍历右子树 vector&lt;int&gt; left_pre,right_pre,left_vin,right_vin; //前序遍历的第一个节点一定是根节点 TreeNode* head=new TreeNode(pre[0]); //找到中序遍历的根节点 int root=0; //遍历找到中序遍历根节点索引值 for(int i=0;i&lt;vin.size();i++)&#123; if(pre[0]==vin[i])&#123; root=i; break; &#125; &#125; //利用中序遍历的根节点，对二叉树结点进行归并 for(int i=0;i&lt;root;i++)&#123; left_vin.push_back(vin[i]); left_pre.push_back(pre[i+1]); &#125; for(int i=root+1;i&lt;pre.size();i++)&#123; right_vin.push_back(vin[i]); right_pre.push_back(pre[i]); &#125; //递归，再区分左右子树的个数，直到叶节点 head-&gt;left=reConstructBinaryTree(left_pre,left_vin); head-&gt;right=reConstructBinaryTree(right_pre,right_vin); return head; &#125;&#125;; Python代码： 1234567891011121314151617181920# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0: return None elif len(pre) == 1: return TreeNode(pre[0]) else: root = TreeNode(pre[0]) pos = tin.index(pre[0]) root.left = self.reConstructBinaryTree(pre[1:pos+1],tin[:pos]) root.right = self.reConstructBinaryTree(pre[pos+1:],tin[pos+1:]) return root]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习(-)K-近邻算法]]></title>
    <url>%2F2019%2F12%2F30%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一：简单K-近邻算法本文将从k-近邻（kNN）算法的思想开始讲起，使用python3一步一步编写代码进行实战训练。并且，我也提供了相应的数据集，对代码进行了详细的注释。除此之外，本文也对sklearn实现k-近邻算法的方法进行了讲解。实战实例：电影类别分类、约会网站配对效果判定、手写数字识别。 k-近邻法简介k近邻法(k-nearest neighbor, k-NN)是1967年由Cover T和Hart P提出的一种基本分类与回归方法。它的工作原理是：存在一个样本数据集合，也称作为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新的数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本最相似数据(最近邻)的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。举个简单的例子，我们可以使用k-近邻算法分类一个电影是爱情片还是动作片。表1.1 就是我们已有的数据集合，也就是训练样本集。这个数据集有两个特征，即打斗镜头数和接吻镜头数。除此之外，我们也知道每个电影的所属类型，即分类标签。用肉眼粗略地观察，接吻镜头多的，是爱情片。打斗镜头多的，是动作片。以我们多年的看片经验，这个分类还算合理。如果现在给我一部电影，你告诉我这个电影打斗镜头数和接吻镜头数。不告诉我这个电影类型，我可以根据你给我的信息进行判断，这个电影是属于爱情片还是动作片。而k-近邻算法也可以像我们人一样做到这一点，不同的地方在于，我们的经验更”牛逼”，而k-近邻算法是靠已有的数据。比如，你告诉我这个电影打斗镜头数为2，接吻镜头数为102，我的经验会告诉你这个是爱情片，k-近邻算法也会告诉你这个是爱情片。你又告诉我另一个电影打斗镜头数为49，接吻镜头数为51，我”邪恶”的经验可能会告诉你，这有可能是个”爱情动作片”，画面太美，我不敢想象。 (如果说，你不知道”爱情动作片”是什么？请评论留言与我联系，我需要你这样像我一样纯洁的朋友。) 但是k-近邻算法不会告诉你这些，因为在它的眼里，电影类型只有爱情片和动作片，它会提取样本集中特征最相似数据(最邻近)的分类标签，得到的结果可能是爱情片，也可能是动作片，但绝不会是”爱情动作片”。当然，这些取决于数据集的大小以及最近邻的判断标准等因素。 距离量度我们已经知道k-近邻算法根据特征比较，然后提取样本集中特征最相似数据(最邻近)的分类标签。那么，如何进行比较呢？比如，我们还是以表1.1为例，怎么判断红色圆点标记的电影所属的类别呢？ 如下图所示。我们可以从散点图大致推断，这个红色圆点标记的电影可能属于动作片，因为距离已知的那两个动作片的圆点更近。k-近邻算法用什么方法进行判断呢？没错，就是距离度量。这个电影分类的例子有2个特征，也就是在2维实数向量空间，可以使用我们高中学过的两点距离公式计算距离，通过计算，我们可以得到如下结果： (101,20)-&gt;动作片(108,5)的距离约为16.55(101,20)-&gt;动作片(115,8)的距离约为18.44(101,20)-&gt;爱情片(5,89)的距离约为118.22(101,20)-&gt;爱情片(1,101)的距离约为128.69通过计算可知，红色圆点标记的电影到动作片 (108,5)的距离最近，为16.55。如果算法直接根据这个结果，判断该红色圆点标记的电影为动作片，这个算法就是最近邻算法，而非k-近邻算法。那么k-近邻算法是什么呢？k-近邻算法步骤如下： 计算已知类别数据集中的点与当前点之间的距离；按照距离递增次序排序；选取与当前点距离最小的k个点；确定前k个点所在类别的出现频率；返回前k个点所出现频率最高的类别作为当前点的预测分类。比如，现在我这个k值取3，那么在电影例子中，按距离依次排序的三个点分别是动作片(108,5)、动作片(115,8)、爱情片(5,89)。在这三个点中，动作片出现的频率为三分之二，爱情片出现的频率为三分之一，所以该红色圆点标记的电影为动作片。这个判别过程就是k-近邻算法。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# -*- coding: UTF-8 -*-import numpy as npimport operator"""函数说明:创建数据集 Parameters: 无Returns: group - 数据集 labels - 分类标签Modify: 2019-12-30"""def createDataSet(): #四组二维特征 group = np.array([[1,101],[5,89],[108,5],[115,8]]) #四组特征的标签 labels = ['爱情片','爱情片','动作片','动作片'] return group, labels"""函数说明:kNN算法,分类器 Parameters: inX - 用于分类的数据(测试集) dataSet - 用于训练的数据(训练集) labes - 分类标签 k - kNN算法参数,选择距离最小的k个点Returns: sortedClassCount[0][0] - 分类结果 Modify: 2019-12-30"""def classify0(inX,dataSet,labels,k): #numpy函数shape[0]返回dataSet的行数 dataSetSize = dataSet.shape[0] #在列向量方向上重复inX共1次(横向)，行向量方向上重复inX共dataSetSize次(纵向) diffMat = np.tile(inX,(dataSetSize,1))-dataSet #二维特征相减后平方 sqDiffMat = diffMat**2 #sum()所有元素相加，sum(0)列相加，sum(1)行相加 sqDistance = sqDiffMat.sum(axis=1) #开方，计算出距离 distances = sqDistance**0.5 #返回distances中元素从小到大排序后的索引值 sortedDistIndices = distances.argsort() #定一个记录类别次数的字典 classCount = &#123;&#125; for i in range(k): #取出前k个元素的类别 voteIlable = labels[sortedDistIndices[i]] #dict.get(key,default=None),字典的get()方法,返回指定键的值,如果值不在字典中返回默认值。 #计算类别次数 classCount[voteIlable] = classCount.get(voteIlable,0)+1 #python3中用items()替换python2中的iteritems() #key=operator.itemgetter(1)根据字典的值进行排序 #key=operator.itemgetter(0)根据字典的键进行排序 #reverse降序排序字典 sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True) #返回次数最多的类别,即所要分类的类别 return sortedClassCount[0][0]if __name__ == '__main__': #创建数据集 group, labels = createDataSet() #测试集 test = [101,20] #KNN分类 test_class = classify0(test,group,labels,3) #打印分类结果 print(test_class) 结果展示可以看到，分类结果根据我们的”经验”，是正确的，尽管这种分类比较耗时，用时1.2s。到这里，也许有人早已经发现，电影例子中的特征是2维的，这样的距离度量可以用两 点距离公式计算，但是如果是更高维的呢？对，没错。我们可以用欧氏距离(也称欧几里德度量)，如图1.5所示。我们高中所学的两点距离公式就是欧氏距离在二维空间上的公式，也就是欧氏距离的n的值为2的情况。二：k-近邻算法实战之约会网站配对效果判定k-近邻算法的一般流程： 收集数据：可以使用爬虫进行数据的收集，也可以使用第三方提供的免费或收费的数据。一般来讲，数据放在txt文本文件中，按照一定的格式进行存储，便于解析及处理。 准备数据：使用Python解析、预处理数据。 分析数据：可以使用很多方法对数据进行分析，例如使用Matplotlib将数据可视化。 测试算法：计算错误率。 使用算法：错误率在可接受范围内，就可以运行k-近邻算法进行分类。 实战内容海伦女士一直使用在线约会网站寻找适合自己的约会对象。尽管约会网站会推荐不同的任选，但她并不是喜欢每一个人。经过一番总结，她发现自己交往过的人可以进行如下分类： 不喜欢的人 魅力一般的人 极具魅力的人 海伦收集约会数据已经有了一段时间，她把这些数据存放在文本文件datingTestSet.txt中，每个样本数据占据一行，总共有1000行。 海伦收集的样本数据主要包含以下3种特征： 每年获得的飞行常客里程数玩视频游戏所消耗时间百分比每周消费的冰淇淋公升数这里不得不吐槽一句，海伦是个小吃货啊，冰淇淋公斤数都影响自己择偶标准。打开txt文本文件。 准备数据：数据解析在将上述特征数据输入到分类器前，必须将待处理的数据的格式改变为分类器可以接收的格式。分类器接收的数据是什么格式的？从上小结已经知道，要将数据分类两部分，即特征矩阵和对应的分类标签向量。在kNN_test02.py文件中创建名为file2matrix的函数，以此来处理输入格式问题。 将datingTestSet.txt放到与kNN_test02.py相同目录下，编写代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# -*- coding: UTF-8 -*-import numpy as np"""函数说明:打开并解析文件，对数据进行分类：1代表不喜欢,2代表魅力一般,3代表极具魅力Parameters: filename - 文件名Returns: returnMat - 特征矩阵 classLabelVector - 分类Label向量Modify: 2019-12-30"""def filematrix(filename): #打开文件 fr = open(filename) #读取文件所有内容 arrayOLines = fr.readlines() #得到文件行数 numberOfLines = len(arrayOLines) #返回的NumPy矩阵,解析完成的数据:numberOfLines行,3列 returnMat = np.zeros((numberOfLines,3)) #返回的分类标签向量 classLabelVector = [] #行的索引值 index = 0 for line in arrayOLines: #s.strip(rm)，当rm空时,默认删除空白符(包括'\n','\r','\t',' ') line = line.strip() #使用s.split(str="",num=string,cout(str))将字符串根据'\t'分隔符进行切片。 listFromLine = line.split('\t') #将数据前三列提取出来,存放到returnMat的NumPy矩阵中,也就是特征矩阵 returnMat[index,:] = listFromLine[0:3] #根据文本中标记的喜欢的程度进行分类,1代表不喜欢,2代表魅力一般,3代表极具魅力 if listFromLine[-1] == 'didntLike': classLabelVector.append(1) elif listFromLine[-1] == 'smallDoses': classLabelVector.append(2) elif listFromLine[-1] == 'largeDoses': classLabelVector.append(3) index += 1 return returnMat, classLabelVector"""函数说明:main函数Parameters: 无Returns: 无Modify: 2019-12-30"""if __name__ == '__main__': #打开的文件名 filename = "datingTestSet.txt" #打开并处理数据 datingDataMat, datingLabels = filematrix(filename) print(datingDataMat) print(datingLabels) 运行上述代码，得到的数据解析结果如图可以看到，我们已经顺利导入数据，并对数据进行解析，格式化为分类器需要的数据格式。接着我们需要了解数据的真正含义。可以通过友好、直观的图形化的方式观察数据。 3.分析数据：数据可视化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135# -*- coding: UTF-8 -*-from matplotlib.font_manager import FontPropertiesimport matplotlib.lines as mlinesimport matplotlib.pyplot as pltimport numpy as np"""函数说明:打开并解析文件，对数据进行分类：1代表不喜欢,2代表魅力一般,3代表极具魅力Parameters: filename - 文件名Returns: returnMat - 特征矩阵 classLabelVector - 分类Label向量Modify: 2019-12-30"""def filematrix(filename): #打开文件 fr = open(filename) #读取文件所有内容 arrayOLines = fr.readlines() #得到文件行数 numberOfLines = len(arrayOLines) #返回的NumPy矩阵,解析完成的数据:numberOfLines行,3列 returnMat = np.zeros((numberOfLines,3)) #返回的分类标签向量 classLabelVector = [] #行的索引值 index = 0 for line in arrayOLines: #s.strip(rm)，当rm空时,默认删除空白符(包括'\n','\r','\t',' ') line = line.strip() #使用s.split(str="",num=string,cout(str))将字符串根据'\t'分隔符进行切片。 listFromLine = line.split('\t') #将数据前三列提取出来,存放到returnMat的NumPy矩阵中,也就是特征矩阵 returnMat[index,:] = listFromLine[0:3] #根据文本中标记的喜欢的程度进行分类,1代表不喜欢,2代表魅力一般,3代表极具魅力 if listFromLine[-1] == 'didntLike': classLabelVector.append(1) elif listFromLine[-1] == 'smallDoses': classLabelVector.append(2) elif listFromLine[-1] == 'largeDoses': classLabelVector.append(3) index += 1 return returnMat, classLabelVector"""函数说明:可视化数据Parameters: datingDataMat - 特征矩阵 datingLabels - 分类LabelReturns: 无Modify: 2019-12-30"""def showdatas(datingDataMat, datingLabels): #设置汉字格式 font = FontProperties(fname=r"c:\windows\fonts\simsun.ttc", size=14) #将fig画布分隔成1行1列,不共享x轴和y轴,fig画布的大小为(13,8) #当nrow=2,nclos=2时,代表fig画布被分为四个区域,axs[0][0]表示第一行第一个区域 fig, axs = plt.subplots(nrows=2, ncols=2,sharex=False, sharey=False, figsize=(13,8)) numberOfLabels = len(datingLabels) LabelsColors = [] for i in datingLabels: if i == 1: LabelsColors.append('black') if i == 2: LabelsColors.append('orange') if i == 3: LabelsColors.append('red') #画出散点图,以datingDataMat矩阵的第一(飞行常客例程)、第二列(玩游戏)数据画散点数据,散点大小为15,透明度为0.5 axs[0][0].scatter(x=datingDataMat[:,0], y=datingDataMat[:,1], color=LabelsColors,s=15, alpha=.5) #设置标题,x轴label,y轴label axs0_title_text = axs[0][0].set_title(u'每年获得的飞行常客里程数与玩视频游戏所消耗时间占比',FontProperties=font) axs0_xlabel_text = axs[0][0].set_xlabel(u'每年获得的飞行常客里程数',FontProperties=font) axs0_ylabel_text = axs[0][0].set_ylabel(u'玩视频游戏所消耗时间占',FontProperties=font) plt.setp(axs0_title_text, size=9, weight='bold', color='red') plt.setp(axs0_xlabel_text, size=7, weight='bold', color='black') plt.setp(axs0_ylabel_text, size=7, weight='bold', color='black') #画出散点图,以datingDataMat矩阵的第一(飞行常客例程)、第三列(冰激凌)数据画散点数据,散点大小为15,透明度为0.5 axs[0][1].scatter(x=datingDataMat[:,0], y=datingDataMat[:,2], color=LabelsColors,s=15, alpha=.5) #设置标题,x轴label,y轴label axs1_title_text = axs[0][1].set_title(u'每年获得的飞行常客里程数与每周消费的冰激淋公升数',FontProperties=font) axs1_xlabel_text = axs[0][1].set_xlabel(u'每年获得的飞行常客里程数',FontProperties=font) axs1_ylabel_text = axs[0][1].set_ylabel(u'每周消费的冰激淋公升数',FontProperties=font) plt.setp(axs1_title_text, size=9, weight='bold', color='red') plt.setp(axs1_xlabel_text, size=7, weight='bold', color='black') plt.setp(axs1_ylabel_text, size=7, weight='bold', color='black') #画出散点图,以datingDataMat矩阵的第二(玩游戏)、第三列(冰激凌)数据画散点数据,散点大小为15,透明度为0.5 axs[1][0].scatter(x=datingDataMat[:,1], y=datingDataMat[:,2], color=LabelsColors,s=15, alpha=.5) #设置标题,x轴label,y轴label axs2_title_text = axs[1][0].set_title(u'玩视频游戏所消耗时间占比与每周消费的冰激淋公升数',FontProperties=font) axs2_xlabel_text = axs[1][0].set_xlabel(u'玩视频游戏所消耗时间占比',FontProperties=font) axs2_ylabel_text = axs[1][0].set_ylabel(u'每周消费的冰激淋公升数',FontProperties=font) plt.setp(axs2_title_text, size=9, weight='bold', color='red') plt.setp(axs2_xlabel_text, size=7, weight='bold', color='black') plt.setp(axs2_ylabel_text, size=7, weight='bold', color='black') #设置图例 didntLike = mlines.Line2D([], [], color='black', marker='.', markersize=6, label='didntLike') smallDoses = mlines.Line2D([], [], color='orange', marker='.', markersize=6, label='smallDoses') largeDoses = mlines.Line2D([], [], color='red', marker='.', markersize=6, label='largeDoses') #添加图例 axs[0][0].legend(handles=[didntLike,smallDoses,largeDoses]) axs[0][1].legend(handles=[didntLike,smallDoses,largeDoses]) axs[1][0].legend(handles=[didntLike,smallDoses,largeDoses]) #显示图片 plt.show()"""函数说明:main函数Parameters: 无Returns: 无Modify: 2019-12-30"""if __name__ == '__main__': #打开的文件名 filename = "datingTestSet.txt" #打开并处理数据 datingDataMat, datingLabels = filematrix(filename) showdatas(datingDataMat, datingLabels) 运行上述代码，可以看到可视化结果如图通过数据可以很直观的发现数据的规律，比如以玩游戏所消耗时间占比与每年获得的飞行常客里程数，只考虑这二维的特征信息，给我的感觉就是海伦喜欢有生活质量的男人。为什么这么说呢？每年获得的飞行常客里程数表明，海伦喜欢能享受飞行常客奖励计划的男人，但是不能经常坐飞机，疲于奔波，满世界飞。同时，这个男人也要玩视频游戏，并且占一定时间比例。能到处飞，又能经常玩游戏的男人是什么样的男人？很显然，有生活质量，并且生活悠闲的人。我的分析，仅仅是通过可视化的数据总结的个人看法。我想，每个人的感受应该也是不尽相同。 注：机器学习系列只为博主熟悉机器学习实战的记录，文章部分篇幅也是从其他处寻找。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03从尾到头打印链表]]></title>
    <url>%2F2019%2F12%2F30%2F03%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目：输入一个链表，返回一个反序的链表。 分析：通常，这种情况下，我们不希望修改原链表的结构。返回一个反序的链表，这就是经典的“后进先出”，我们可以使用栈实现这种顺序。每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，给一个新的链表结构，这样链表就实现了反转。 c++代码： 123456789101112131415161718192021222324252627/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; stack&lt;int&gt;nodes; vector&lt;int&gt; res; listNode* node=head; while(node!=NULL)&#123; nodes.push(node-&gt;val); node=node-&gt;next; &#125; while(!nodes.empty())&#123; res.push_back(nodes.top()); nodes.pop(); &#125; return res; &#125;&#125;; python代码： 123456789101112131415# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here res = [] while listNode: res.insert(0,listNode.val) listNode = listNode.next return res]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02替换空格]]></title>
    <url>%2F2019%2F12%2F30%2F02%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 分析：最简单的方法就是从头到尾遍历，但是时间复杂度为O(n^2)。本文采用一种时间复杂度为O(n)的方法。 我们可以先遍历一次字符串，这样就可以统计出字符串空格的总数，并可以由此计算出替换之后的字符串的总长度。每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\n”），里面有两个空格，因此替换之后字符串的长度是18。 我们从字符串的尾部开始复制和替换。首先准备两个指针，P1和P2，P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。碰到第一个空格之后，把P1向前移动1格，在P2之前插入字符串”%20”。由于”%20”的长度为3，同时也要把P2向前移动3格。 1234567891011121314151617181920class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int numSpace=0; int i=0; while(str[i]!='\0')&#123; if(str[i]==' ')numSpace++; i++; &#125; int newLen=length+2*numSpace; for(int j=length;j&gt;=0&amp;&amp;newLen&gt;=0;j--)&#123; if(str[j]==' ')&#123; str[newLen--]='0'; str[newLen--]='2'; str[newLen--]='%'; &#125; else str[newLen]=str[j]; &#125; &#125;&#125;; 123456# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here return s.replace(' ','%20')]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01二维数组中的查找]]></title>
    <url>%2F2019%2F12%2F29%2F01%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 分析：首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。 如果在一个二维数组中找到数字7，则返回true，如果没有找到，则返回false。 1234567891011121314151617class solution&#123;public: bool Find(int target,vector&lt;vector&lt;int&gt; &gt;array)&#123; int rows=array.size(); int cols=array[0].size(); if(!array.empty()&amp;&amp;rows&gt;0&amp;&amp;cols&gt;0)&#123; int row=0; int col=cols-1; while(row&lt;=rows-1&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) return true; else if(array[row][col]&gt;target) col--; else row++; &#125; &#125; return false; &#125;&#125;;]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用urllib.urlopen向有道翻译发送数据获取翻译结果]]></title>
    <url>%2F2019%2F12%2F29%2F%E5%88%A9%E7%94%A8urllib-urlopen%E5%90%91%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E7%BF%BB%E8%AF%91%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[urlopen的data参数 我们可以使用data参数，向服务器发送数据。根据HTTP规范，GET用于信息获取，POST是向服务器提交数据的一种请求，再换句话说： 从客户端向服务器提交数据使用POST； 从服务器获得数据到客户端使用GET(GET也可以提交，暂不考虑)。 如果没有设置urlopen()函数的data参数，HTTP请求采用GET方式，也就是我们从服务器获取信息，如果我们设置data参数，HTTP请求采用POST方式，也就是我们向服务器传递数据。 data参数有自己的格式，它是一个基于application/x-www.form-urlencoded的格式，具体格式我们不用了解， 因为我们可以使用urllib.parse.urlencode()函数将字符串自动转换成上面所说的格式。 发送data实例 记住这些信息，这是我们一会儿写程序需要用到的。 1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-from urllib import requestfrom urllib import parseimport jsonif __name__ == "__main__": #对应上图的Request URL Request_URL = 'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;smartresult=ugc&amp;sessionFrom=https://www.baidu.com/link' #创建Form_Data字典，存储上图的Form Data Form_Data = &#123;&#125; Form_Data['type'] = 'AUTO' Form_Data['i'] = 'brave' Form_Data['doctype'] = 'json' Form_Data['Version'] = '2.1' Form_Data['keyfrom'] = 'fanyi.web' Form_Data['ue'] = 'ue:UTF-8' Form_Data['action'] = 'FY_BY_CLICKBUTTON' #使用urlencode方法转换标准格式 data = parse.urlencode(Form_Data).encode('utf-8') #传递Request对象和转换完格式的数据 response = request.urlopen(Request_URL,data) #读取信息并解码 html = response.read().decode('utf-8') #使用JSON translate_results = json.loads(html) #找到翻译结果 translate_results = translate_results['translateResult'][0][0]['tgt'] #打印翻译信息 print("翻译的结果是：%s" % translate_results)]]></content>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell模拟考勤程序]]></title>
    <url>%2F2019%2F11%2F03%2FShell%E6%A8%A1%E6%8B%9F%E8%80%83%E5%8B%A4%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[shell语法 任务：设计一个考勤模拟程序，实现如下功能选择界面，要求使用函数 1. 上班签到 2. 下班签出 3. 缺勤信息查阅 4. 退出 考勤程序运行后，提示用户输入上述功能选择，并验证用户输入的用户名和密码；用户信息保存在userinfo.dat中。 如果是上班签到，记录签到信息，如果签到时间大于上午8时，则提示用户迟到，并记录该迟到信息到check.dat。 如果是下班签出，记录签出信息，如果签出时间小于下午6时，则提示用户早退，并记录该早退信息到check.dat。 如果用户选择缺勤信息查询，则将check.dat中对应该用户的迟到早退信息查出并显示。 用户选择功能执行完，shell程序继续回到功能选择界面等待下一个用户进行操作。 实验环境 基于linux的deepin系统（优点：界面也太好看了吧 缺点：生态没有ubuntu Centos Arch完善） 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#!/usr/bin/env bash# 考勤模拟程序#作者：Bravewtz#date 2019/11/01function main()&#123; echo "----------Bravewtz提醒您-------------------------" echo " 欢迎使用考勤程序！ " echo "------------------------------------------------" createInfoFile; read -p "请输入您的账号： " username read -p "请输入您的密码： " passwordisLogin $username $password; while [[ 1 == 1 ]]; do menu; read -p "请输入您的选择：" choice case $choice in 1 ) signIn $username; ;; 2 ) logOff $username; ;; 3 ) absenceConsult $username; ;; 4 ) exit1; ;; * ) echo -e "请选择功能 1 or 2 or 3 or 4！\n" ;; esac done&#125;#菜单function menu()&#123; echo "------------------------------------------------------------" echo " 1.上班签到 " echo " 2.下班签出 " echo " 3.缺勤信息查阅 " echo " 4.退出 " echo "------------------------------------------------------------"&#125;#检查账号密码function isLogin()&#123; while read line do if [[ "$line" == "$1:$2" ]]; then return 0 fi done &lt; userinfo.dat #从文件读入 echo "用户名或密码错误，请重新输入哦" read -p "请输入您的账号： " username read -p "请输入您的密码： " passwordisLogin $username $password;&#125;#上班签到function signIn()&#123; hour=`date +%H` if [[ $hour -gt 8 ]]; then echo "你上班迟到了呀！已经将迟到信息记录在check.dat中。" echo "$1 上班迟到————日期：`date`" &gt;&gt; check.dat else echo "上班签到成功！" fi main;&#125;#下班迁出function logOff()&#123; echo "下班签出成功！" hour=`date +%H` if [[ $hour -lt 18 ]]; then echo "你现在属于早退哦！已经将早退信息记录在check.dat中。" echo "$1 下班早退————日期：`date`" &gt;&gt; check.dat fi main;&#125;#缺勤查阅function absenceConsult()&#123; cat check.dat|grep -n "$1"&#125;#退出程序function exit1()&#123; exit 0&#125;s#创建配置文件ssfunction createInfoFile()&#123; if [[ ! -e userinfo.dat ]]; then touch userinfo.dat #保存用户名和密码 chmod 777 userinfo.dat fi if [[ ! -e check.dat ]]; then touch check.dat #保存迟到早退信息 chmod 777 check.dat fi&#125;#执行main函数main 实验结果]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCv透视变换原理及实现]]></title>
    <url>%2F2019%2F10%2F31%2FOpenCv%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[OpenCV提供了两种图片变换的方式：仿射变换和透视变换，两者的区别很容易区分 前者是将矩形的图片变成平行四边形 后者是将图片变成梯形 这两种变换虽然都有各自的应用场景，但在实际的图片变换中由于透视效应的存在，后者的使用更加普遍，本文为大家详解OpenCV透视变换的透视变换原理及实例展示。简介透视变换(Perspective Transformation)是将成像投影到一个新的视平面(Viewing Plane)，也称作投影映射(Projective Mapping)。如图所示 函数原型OpenCV提供了warpPerspective( )函数来实现图片的透视变换，只需要输入梯形四个顶点的坐标和目标画布四个角的坐标，即可自动完成转换。核心代码只有两行：首先读取两个坐标数组，计算变换矩阵；然后根据变换矩阵对原图进行透视变换，并输出到目标画布。 cv2.getPerspectiveTransform(src, dst) → retval 参数说明 src：源图像中待测矩形的四点坐标 sdt：目标图像中矩形的四点坐标原图像的四个坐标顺序应与目标图像中的四个坐标一 一随影，若都是顺时针则都是顺时针，若都是 Z 字型，则都是 Z 字型。返回由源图像中矩形到目标图像矩形变换的矩阵，得到矩阵得有用才行啊，所以引出下面这个函数 cv2.warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) → dst参数为： src：输入图像M：变换矩阵dsize：目标图像shapeflags：插值方式，interpolation方法INTER_LINEAR或INTER_NEARESTborderMode：边界补偿方式，BORDER_CONSTANT or BORDER_REPLICATEborderValue：边界补偿大小，常值，默认为0或者 cv2.perspectiveTransform(src, m[, dst]) → dst 参数解释 src：输入的2通道或者3通道的图片 m：变换矩阵实例1 图片矫正我们在给报纸、杂志、身份证、银行卡等矩形目标拍照时，受相机角度和高度的影响往往会拍出梯形的照片（如下图），这样的照片不仅不够美观而且给文字识别带来较大难度，将梯形的图片转换成标准的矩形就要对图片进行透视变换。原始图像效果如下：转换后的效果如下图所示，效果还是很让人满意的。实例 2 头像替换广告牌在实际应用中我们不仅需要将梯形矫正为矩形，有时还需要将矩形转换成梯形，warpPerspective( )当然也能胜任，下面我们再用一个例子来演示。实际效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[双线型插值法及其py缩放实现]]></title>
    <url>%2F2019%2F10%2F22%2F%E5%8F%8C%E7%BA%BF%E5%9E%8B%E6%8F%92%E5%80%BC%E6%B3%95%E5%8F%8A%E5%85%B6py%E7%BC%A9%E6%94%BE%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[双线性插值假设源图像大小为mxn，目标图像为axb。那么两幅图像的边长比分别为：m/a和n/b。注意，通常这个比例不是整数，编程存储的时候要用浮点型。目标图像的第（i,j）个像素点（i行j列）可以通过边长比对应回源图像。其对应坐标为（im/a,jn/b）。显然，这个对应坐标一般来说不是整数，而非整数的坐标是无法在图像这种离散数据上使用的。双线性插值通过寻找距离这个对应坐标最近的四个像素点，来计算该点的值（灰度值或者RGB值）。 若图像为灰度图像，那么（i，j）点的灰度值的数学计算模型是 f(x,y)=b1+b2x+b3y+b4xy 如图，已知Q12，Q22，Q11，Q21，但是要插值的点为P点，这就要用双线性插值了，首先在x轴方向上，对R1和R2两个点进行插值，这个很简单，然后根据R1和R2对P点进行插值，这就是所谓的双线性插值。在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。 假如我们想得到未知函数 f 在点 P = (x, y) 的值，假设我们已知函数 f 在 Q11 = (x1, y1)、Q12 = (x1, y2), Q21 = (x2, y1) 以及 Q22 = (x2, y2) 四个点的值。首先在 x 方向进行线性插值，得到然后在 y 方向进行线性插值，得到这样就得到所要的结果 f(x, y)，如果选择一个坐标系统使得 的四个已知点坐标分别为 (0, 0)、(0, 1)、(1, 0) 和 (1, 1)，那么插值公式就可以化简为或者用矩阵运算表示为这种插值方法的结果通常不是线性的，线性插值的结果与插值的顺序无关。首先进行 y 方向的插值，然后进行 x 方向的插值，所得到的结果是一样的。 python代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445 #--*-- encoding: utf-8 --*--'''Date: 2019.10.22Content: python3 实现双线性插值图像缩放算法'''import numpy as npimport cv2import mathdef bi_linear(src, dst, target_size): pic = cv2.imread(src) # 读取输入图像 th, tw = target_size[0], target_size[1] emptyImage = np.zeros(target_size, np.uint8) for k in range(3): for i in range(th): for j in range(tw): # 首先找到在原图中对应的点的(X, Y)坐标 corr_x = (i+0.5)/th*pic.shape[0]-0.5 corr_y = (j+0.5)/tw*pic.shape[1]-0.5 # if i*pic.shape[0]%th==0 and j*pic.shape[1]%tw==0: # 对应的点正好是一个像素点，直接拷贝 # emptyImage[i, j, k] = pic[int(corr_x), int(corr_y), k] point1 = (math.floor(corr_x), math.floor(corr_y)) # 左上角的点 point2 = (point1[0], point1[1]+1) point3 = (point1[0]+1, point1[1]) point4 = (point1[0]+1, point1[1]+1) fr1 = (point2[1]-corr_y)*pic[point1[0], point1[1], k] + (corr_y-point1[1])*pic[point2[0], point2[1], k] fr2 = (point2[1]-corr_y)*pic[point3[0], point3[1], k] + (corr_y-point1[1])*pic[point4[0], point4[1], k] emptyImage[i, j, k] = (point3[0]-corr_x)*fr1 + (corr_x-point1[0])*fr2 cv2.imwrite(dst, emptyImage) # 用 CV2 resize函数得到的缩放图像 new_img = cv2.resize(pic, (200, 300)) cv2.imwrite('pic/1_cv_img.png', new_img)def main(): src = './sucai1.jpg' dst = './sucai1_linear.png' target_size = (300, 200, 3) # 变换后的图像大小 bi_linear(src, dst, target_size)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>双线性插值法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PAT】甲级-1053 Path of Equal Weight]]></title>
    <url>%2F2019%2F10%2F18%2F%E3%80%90PAT%E3%80%91%E7%94%B2%E7%BA%A7-1053-Path-of-Equal-Weight%2F</url>
    <content type="text"><![CDATA[题目链接 Given a non-empty tree with root R, and with weight W​i​​assigned to each tree node T​i​​. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure. Input Specification: 123456789Each input file contains one test case. Each case starts with a line containing 0&lt;N≤100, the number of nodes in a tree, M (&lt;N), the number of non-leaf nodes, and 0&lt;S&lt;2​30​​, the given weight number. The next line contains N positive numbers where W​i​​(&lt;1000) corresponds to the tree node T​i​​. Then M lines follow, each in the format:ID K ID[1] ID[2] ... ID[K]where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID's of its children. For the sake of simplicity, let us fix the root ID to be 00. Output Specification: 1For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line. AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5+10;#define LL long long#define INF 0x3f3f3f3fstruct NODE&#123; int w; vector&lt;int&gt; child;&#125;;vector&lt;NODE&gt; V;vector&lt;int&gt; path;int ans;void dfs(int index,int nodeNum,int sum)&#123; if(sum&gt;ans) return ; if(sum==ans)&#123; if(V[index].child.size()!=0) return ; for(int i=0;i&lt;nodeNum;i++)&#123; printf("%d%c",V[path[i]].w,i!=nodeNum-1?' ':'\n'); &#125; return ; &#125; for(int i=0;i&lt;V[index].child.size();i++)&#123; int node=V[index].child[i]; path[nodeNum]=node; dfs(node,nodeNum+1,sum+V[node].w); &#125;&#125;int cmp(int a,int b)&#123; return V[a].w&gt;V[b].w; &#125;int main()&#123; int n,m,node,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;ans); V.resize(n); path.resize(n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;V[i].w); for(int i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;node,&amp;k); V[node].child.resize(k); for(int j=0;j&lt;k;j++)&#123; scanf("%d",&amp;V[node].child[j]); &#125; sort(V[node].child.begin(),V[node].child.end(),cmp); &#125; dfs(0,1,V[0].w); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PAT】甲级-Set Similarity (STL)]]></title>
    <url>%2F2019%2F10%2F15%2F%E3%80%90PAT%E3%80%91%E7%94%B2%E7%BA%A7-Set-Similarity-STL%2F</url>
    <content type="text"><![CDATA[题目链接 Given two sets of integers, the similarity of the sets is defined to be Nc​​/N​t​​×100%, where Nc​​is the number of distinct common numbers shared by the two sets, and Nt ​​is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets. Input Specification: 12345Each input file contains one test case. Each case first gives a positive integer N (≤50) which is the total number of sets. Then N lines follow, each gives a set with a positive M (≤10​4​​) and followed by M integers in the range [0,10​9​​]. After the input of sets, a positive integer K (≤2000) is given, followed by K lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to N). All the numbers in a line are separated by a space. Output Specification: 1For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place. AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5+10;#define LL long long#define INF 0x3f3f3f3fint n,m,k,tmp,a,b;int main()&#123; scanf("%d",&amp;n); vector&lt;set&lt;int&gt; &gt;V(n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;m); set&lt;int&gt; S; for(int j=0;j&lt;m;j++)&#123; scanf("%d",&amp;tmp); S.insert(tmp); &#125; V[i]=S; &#125; scanf("%d",&amp;k); for(int i=0;i&lt;k;i++)&#123; scanf("%d%d",&amp;a,&amp;b); int nc=0,nt=V[b-1].size(); for(auto it=V[a-1].begin();it!=V[a-1].end();it++)&#123; if(V[b-1].find(*it)==V[b-1].end())&#123; nt++; &#125; else nc++; &#125; double ans=(double)nc/nt*100; printf("%.1f%%\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PAT】甲级-1049 Counting Ones数学]]></title>
    <url>%2F2019%2F10%2F14%2F%E3%80%90PAT%E3%80%91%E7%94%B2%E7%BA%A7-1049-Counting-Ones%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[题目链接 The task is simple: given any positive integer N, you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to N. For example, given N being 12, there are five 1’s in 1, 10, 11, and 12. Input Specification: 123Each input file contains one test case which gives the positive N (≤2​30​​ ). Output Specification: 1For each test case, print the number of 1's in one line. 分析 从第一位到最高位，设now为当前位的数字，left为now左边的所有数字构成的数字，right为now右边所有构成的数字。只需要一次次累加对于当前位now来说可能出现1的个数，然后把他们累加即可。 对于now==0,那么ans+=left*a; //因为now==0说明now位只有在left从0~left-11的时候会产⽣1，所以会产 ⽣left次，但是⼜因为右边会重复从0~999…出现a次其他同理 AC代码 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5+10;#define LL long long#define INF 0x3f3f3f3fint main()&#123; int n,left=0,right=0,a=1,pos,now,ans; scanf("%d",&amp;n); while(n/a)&#123; left=n/(a*10),now=n/a%10,right=n%a; if(now==0) ans+=left*a; else if(now==1) ans+=left*a+right+1; else ans+=(left+1)*a; a*=10; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PAT】甲级 1072 Gas Station 最短路]]></title>
    <url>%2F2019%2F10%2F10%2F%E3%80%90PAT%E3%80%91%E7%94%B2%E7%BA%A7-1072-Gas-Station-%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[题目链接 A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range.Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number. Input Each input file contains one test case. For each case, the first line contains 4 positive integers: N (≤10^3​​), the total number of houses; M (≤10), the total number of the candidate locations for the gas stations; K (≤10^4​​), the number of roads connecting the houses and the gas stations; and D​S​​, the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N, and all the candidate locations are numbered from G1 to GM.Then K lines follow, each describes a road in the formatP1 P2 Distwhere P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road. Output For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution. Input Sample 1234567891011124 3 11 51 2 21 4 21 G1 41 G2 32 3 22 G2 13 4 23 G3 24 G1 3G2 G1 1G3 G2 2 Output Sample 12G12.0 3.3 分析：加油站的输入是字符串形式，可以写个函数处理一下G1=n+1G2=n+2n为居民点个数然后对每一个加油站使用一次spfa求出到所有点的最短路，对得出来的路径分析一下即可出答案 AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2000;#define LL long long#define INF 0x3f3f3f3fstruct edge&#123; int to,w;&#125;;vector&lt;edge&gt; G[maxn];//int G[maxn][maxn]=&#123;0&#125;;typedef pair&lt;int,int&gt; P;int d[maxn];int vis[maxn];int n,m,k,ds;int getnum(string s)&#123; int ans=0; if(s[0]=='G')&#123; for(int i=1;i&lt;s.length();i++)&#123; ans=ans*10+s[i]-'0'; &#125; ans+=n; &#125; else&#123; for(int i=0;i&lt;s.length();i++)&#123; ans=ans*10+s[i]-'0'; &#125; &#125; return ans;&#125;void dijkstra(int s)&#123; priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;pq; memset(d,INF,sizeof(d)); memset(vis,0,sizeof(vis)); d[s]=0; pq.push(P&#123;0,s&#125;); while(!pq.empty())&#123; P p=pq.top(); pq.pop(); int u=p.second; if(vis[u]) continue; vis[u]=1; for(int i=0;i&lt;G[u].size();i++)&#123; edge e=G[u][i]; if(!vis[e.to]&amp;&amp;d[e.to]&gt;d[u]+e.w)&#123; d[e.to]=d[u]+e.w; pq.push(P&#123;d[e.to],e.to&#125;); &#125; &#125;// for(int v=1;v&lt;=n+m;v++)&#123;// if(!vis[v]&amp;&amp;G[u][v]&amp;&amp;d[v]&gt;d[u]+G[u][v])&#123;// d[v]=d[u]+G[u][v];// pq.push(P&#123;d[v],v&#125;);// &#125;// &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;ds); for(int i=0;i&lt;k;i++)&#123; string s1,s2; int dis; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;dis; int u=getnum(s1); int v=getnum(s2);// G[u][v]=G[v][u]=dis; G[u].push_back(edge&#123;v,dis&#125;); G[v].push_back(edge&#123;u,dis&#125;); &#125; double ansdis=0,ansavg=INF; int ansid; for(int s=n+1;s&lt;=n+m;s++)&#123;// memset(vis,0,sizeof(vis)); dijkstra(s); double mindis=INF,avg=0; for(int i=1;i&lt;=n;i++)&#123; if(d[i]&gt;ds)&#123; mindis=-1; break; &#125; if(d[i]&lt;mindis) mindis=d[i]; avg+=d[i]*1.0/n; &#125; if(mindis==-1) continue; if(mindis&gt;ansdis)&#123;//最近的村庄距离最大 ansdis=mindis; ansavg=avg; ansid=s; &#125; else if(mindis==ansdis&amp;&amp;avg&lt;ansavg)&#123; ansavg=avg; ansid=s; &#125; &#125; if(ansavg==INF) printf("No Solution"); else&#123; printf("G%d\n",ansid-n); printf("%.1f %.1f",ansdis,ansavg); &#125; return 0;&#125;/*4 3 11 51 2 21 4 21 G1 41 G2 32 3 22 G2 13 4 23 G3 24 G1 3G2 G1 1G3 G2 2*/]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ - 2785】4 Values whose Sum is 0(折半枚举|双向搜索)]]></title>
    <url>%2F2019%2F10%2F08%2F%E3%80%90POJ-2785%E3%80%914-Values-whose-Sum-is-0-%E6%8A%98%E5%8D%8A%E6%9E%9A%E4%B8%BE-%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[题目链接 https://vjudge.net/problem/POJ-2785 The SUM problem can be formulated as follows: given four lists A, B, C, D of integer values, compute how many quadruplet (a, b, c, d ) ∈ A x B x C x D are such that a + b + c + d = 0 . In the following, we assume that all lists have the same size n . InputThe first line of the input file contains the size of the lists n (this value can be as large as 4000). We then have n lines containing four integer values (with absolute value as large as 2 28 ) that belong respectively to A, B, C and D . OutputFor each input file, your program has to write the number quadruplets whose sum is zero. Sample Input 12345676-45 22 42 -16-41 -27 56 30-36 53 -37 77-36 30 -75 -4626 -38 -10 62-32 -54 -6 45 Sample Output 15 分析：先从CD两个数组中枚举n^2种组合，将其和排好序，然后对AB数组进行二分搜索，复杂度 O(n^2logn) AC代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 4010;#define LL long long#define INF 0x3f3f3f3fint A[maxn],B[maxn],C[maxn],D[maxn];int CD[maxn];int n;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d%d%d",&amp;A[i],&amp;B[i],&amp;C[i],&amp;D[i]); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; CD[i*n+j]=C[i]+D[j]; &#125; sort(CD,CD+n*n); LL ans=0; int sum=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; ans=-(A[i]+B[j]); int cnt=upper_bound(CD,CD+n*n,ans)-lower_bound(CD,CD+n*n,ans); sum+=cnt; &#125; printf("%d\n",sum); return 0;&#125;/*6-45 22 42 -16-41 -27 56 30-36 53 -37 77-36 30 -75 -4626 -38 -10 62-32 -54 -6 45*/]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ - 3723】Conscription（Kruskal变形)]]></title>
    <url>%2F2019%2F10%2F06%2F%E3%80%90POJ-3723%E3%80%91Conscription%EF%BC%88Kruskal%E5%8F%98%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目链接 https://vjudge.net/problem/POJ-3723 Windy has a country, and he wants to build an army to protect his country. He has picked up N girls and M boys and wants to collect them to be his soldiers. To collect a soldier without any privilege, he must pay 10000 RMB. There are some relationships between girls and boys and Windy can use these relationships to reduce his cost. If girl x and boy y have a relationship d and one of them has been collected, Windy can collect the other one with 10000-d RMB. Now given all the relationships between girls and boys, your assignment is to find the least amount of money Windy has to pay. Notice that only one relationship can be used when collecting one soldier. InputThe first line of input is the number of test case.The first line of each test case contains three integers, N, M and R.Then R lines followed, each contains three integers xi, yi and di.There is a blank line before each test case.1 ≤ N, M ≤ 100000 ≤ R ≤ 50,0000 ≤ xi &lt; N0 ≤ yi &lt; M0 &lt; di &lt; 10000 OutputFor each test case output the answer in a single line. Input 123456789101112131415161718192021222325 5 84 3 68311 3 45830 0 65920 1 30633 3 49751 3 20494 2 21042 2 7815 5 102 4 98203 2 62363 1 88642 4 83262 0 51562 0 14634 1 24390 4 43733 4 88892 4 3133 Output 127107154223 分析由于题目男女都是0开始编号，所以我们首先应该对男女进行重新编号，我处理的方法是将女的编号在男的后。然后对于每个关系，我们建立对应一条边，然后求出最小生成树，最后再算出多少人没有被招到即。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 5e4+10;#define LL long long#define INF 0x3f3f3f3fstruct edge&#123; int u,v,w; bool operator&lt;(const edge &amp;x)const&#123; return w&lt;x.w; &#125;&#125;edge[maxn];int n,m,r,pre[maxn];void upset()&#123; for(int i=0;i&lt;n+m;i++) pre[i]=i;&#125;int Find(int x)&#123; int r=x; while(r!=pre[r])&#123; r=pre[r]; &#125; int i=x,j; while(pre[i]!=r)&#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;void mix(int u,int v)&#123; int fu=Find(u); int fv=Find(v); if(fu!=fv) pre[fu]=fv;&#125;int Kruskal()&#123; upset(); int sum=0; int cnt=0; for(int i=0;i&lt;r;i++)&#123; int u=edge[i].u; int v=edge[i].v; if(Find(u)!=Find(v))&#123; sum+=edge[i].w; mix(u,v); cnt++; &#125; if(cnt&gt;=n+m-1) break; &#125; return sum+(n+m-cnt)*10000;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;r); for(int i=0;i&lt;r;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); edge[i].u=u;edge[i].v=n+v; edge[i].w=10000-w; &#125; sort(edge,edge+r); printf("%d\n",Kruskal()); &#125; return 0;&#125;/*25 5 84 3 68311 3 45830 0 65920 1 30633 3 49751 3 20494 2 21042 2 7815 5 102 4 98203 2 62363 1 88642 4 83262 0 51562 0 14634 1 24390 4 43733 4 88892 4 3133*/]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ - 3255】Roadblocks（次短路 Dijkstra算法）]]></title>
    <url>%2F2019%2F10%2F06%2F%E3%80%90POJ-3255%E3%80%91Roadblocks%EF%BC%88%E6%AC%A1%E7%9F%AD%E8%B7%AF-Dijkstra%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Bessie has moved to a small farm and sometimes enjoys returning to visit one of her best friends. She does not want to get to her old home too quickly, because she likes the scenery along the way. She has decided to take the second-shortest rather than the shortest path. She knows there must be some second-shortest path.The countryside consists of R (1 ≤ R ≤ 100,000) bidirectional roads, each linking two of the N (1 ≤ N ≤ 5000) intersections, conveniently numbered 1..N. Bessie starts at intersection 1, and her friend (the destination) is at intersection N.The second-shortest path may share roads with any of the shortest paths, and it may backtrack i.e., use the same road or intersection more than once. The second-shortest path is the shortest path whose length is longer than the shortest path(s) (i.e., if two or more shortest paths exist, the second-shortest path is the one whose length is longer than those but no longer than any other path). Input 123454 41 2 1002 4 2002 3 2503 4 100 Output 1450 分析：求从s到t的次短路径有两种情况： 起点s到某个顶点u的最短路+d(u,t)。 起点到某个顶点u的次短路+d(u,t)。所以更新路径的时候需要把最短路径和次短路径两个都记录下来。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 5000+10;#define LL long long#define INF 0x3f3f3f3ftypedef struct edge&#123; int to,cost; edge(int to,int cost):to(to),cost(cost)&#123;&#125;&#125;edge;typedef pair&lt;int,int&gt; P;vector&lt;edge&gt; G[maxn];int N,R;int dist[maxn];//最短路int dist2[maxn];//次短路priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;pq;int main()&#123; scanf("%d%d",&amp;N,&amp;R); for(int i=0;i&lt;R;i++)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); G[a].push_back(edge&#123;b,c&#125;); G[b].push_back(edge&#123;a,c&#125;); &#125; fill(dist+1,dist+N+1,INF); fill(dist2+1,dist2+N+1,INF); dist[1]=0; pq.push(P&#123;0,1&#125;); while(!pq.empty())&#123; P p=pq.top(); pq.pop(); int u=p.second; if(dist2[u]&lt;p.first) continue;//此路径大于次短路，那么一定大于最短路。剪枝 int d=p.first; for(int i=0;i&lt;G[u].size();i++)&#123; edge e=G[u][i]; int d2=d+e.cost; if(dist[e.to]&gt;d2)&#123;// dist[e.to]=d2; swap(dist[e.to],d2); pq.push(P&#123;dist[e.to],e.to&#125;); &#125; if(dist2[e.to]&gt;d2&amp;&amp;dist[e.to]&lt;d2)&#123; dist2[e.to]=d2; pq.push(P&#123;dist2[e.to],e.to&#125;); &#125; &#125; &#125;// for(int i=1;i&lt;=N;i++)&#123;// printf("%d ",dist[i]);// &#125;// cout&lt;&lt;endl;// for(int i=1;i&lt;=N;i++)&#123;// printf("%d ",dist2[i]);// &#125;// cout&lt;&lt;endl; printf("%d\n",dist2[N]); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路&最小生成树板子整理]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%9D%BF%E5%AD%90%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[dijkstra板子123456789101112131415161718192021222324252627282930313233343536373839优先队列优化：#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std;#define LL long long#define INF 0x3f3f3f3fconst int maxn = 1e5+10;struct edge&#123; int to,cost;&#125;;vector&lt;edge&gt; G[maxn];typedef pair&lt;int,int&gt; P;//first是最短距离，second是顶点编号int d[maxn];int v;void dijkstra(int s)&#123; priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; pq; fill(d,d+v,INF); d[s]=0; pq.push(P&#123;0,s&#125;); while(pq.empty())&#123; P p=pq.top(); pq.pop(); int u=p.second; if(d[u]&lt;p.first) continue; for(int i=0;i&lt;G[u].size();i++)&#123; edge e=G[u][i]; if(d[e.to]&gt;d[u]+e.cost)&#123; d[e.to]=d[u]+e.cost; pq.push(P&#123;d[e.to,e.to&#125;); &#125; &#125; &#125;&#125; Floyed板子123456789101112131415161718192021222324252627typedef struct&#123; char vertex[VertexNum];//顶点表 int edges[VertexNum][VertexNum];//邻接矩阵，可看作边表 int n,e;//图中当前顶点数和边表&#125;MGraph;void Floyed(Mgraph g)&#123; int A[MAXV][MAXV]; int path[MAXV][AMXV]; int i,j,k,n=g.n; for( i=0; i&lt;n; i++ )&#123; for( j=0; j&lt;n; j++ )&#123; A[i][j]=g.edges[i][j]; path[i][j]=-1; &#125; &#125; for(k=0; k&lt;n; k++ )&#123; for(i=0; i&lt;n; i++ )&#123; for( j=0; j&lt;n; j++ )&#123; if(A[i][j]&gt;(A[i][k]+A[k][j]))&#123; A[i][j]=A[i][k]+A[k][j]; path[i][j]=k; &#125; &#125; &#125; &#125;&#125; Prime板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e5+10;#define LL long long#define INF 0x3f3f3f3fint n;int G[maxn][maxn];int dist[maxn];bool vis[maxn];int prim(int cur)&#123;//首个挑选到的结点 int index=cur; int sum=0;//最短路径之和 memset(vis,false,sizeof(vis)); vis[cur]=true; for(int i=0;i&lt;n;i++)&#123; dist[i]=G[cur][i]; &#125; for(int i=1;i&lt;n;i++)&#123; int minn=INF; for(int j=0;j&lt;n;j++)&#123; if(!vis[j]&amp;&amp;dist[j]&lt;minn)&#123; minn=dist[j]; index=j; &#125; &#125; vis[index]=true; sum+=minn; for(int j=0;j&lt;n;j++)&#123; if(!vis[j]&amp;&amp;dist[j]&gt;G[index][j])&#123; dist[j]=G[index][j]; &#125; &#125; &#125; return sum;&#125;int main()&#123; cout&lt;&lt;prime(0)&lt;&lt;endl; return 0;&#125; Kruskal板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 1e3+10;#define LL long long#define INF 0x3f3f3f3fstruct edge&#123; int u,v,cost;&#125;edge[maxn];int pre[maxn];int n,m;//顶点个数，边的个数void upset()&#123; for(int i=1;i&lt;=n;i++) pre[i]=i;&#125;int Find(int x)&#123; int r=x; while(r!=pre[r])&#123; r=pre[r]; &#125; int i=x,j; while(pre[i]!=r)&#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;void mix(int u,int v)&#123; int fu=Find(u),fv=Find(v); pre[fu]=fv;&#125;bool cmp(struct edge a,struct edge b)&#123; return a.cost&lt;=b.cost;&#125;int Kruskal()&#123; int sum=0;//生成树的权值 int cnt=0;//选用边的个数 upset(); for(int i=0;i&lt;m;i++)&#123; int u=edge[i].u; int v=edge[i].v; if(Find(u)!=Find(v))&#123; sum+=edge[i].cost; cnt++; mix(u,v); &#125; if(cnt&gt;=n-1) break; &#125; return sum;&#125;int main()&#123; int u,v,w; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); edge[i].u=u,edge[i].v=v,edge[i].cost=w; &#125; sort(edge,edge+m,cmp); printf("%d\n",Kruskal()); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile简介]]></title>
    <url>%2F2019%2F10%2F05%2FMakefile%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Makefile 简介Makefile 是和 make 命令一起配合使用的.很多大型项目的编译都是通过 Makefile 来组织的, 如果没有 Makefile, 那很多项目中各种库和代码之间的依赖关系不知会多复杂.Makefile的组织流程的能力如此之强, 不仅可以用来编译项目, 还可以用来组织我们平时的一些日常操作. 这个需要大家发挥自己的想象力. Makefile 主要的 5个部分 (显示规则, 隐晦规则, 变量定义, 文件指示, 注释)Makefile基本格式如下: 1234target ... : prerequisites ... command ... ... 其中, target - 目标文件, 可以是 Object File, 也可以是可执行文件prerequisites - 生成 target 所需要的文件或者目标command - make需要执行的命令 (任意的shell命令), Makefile中的命令必须以 [tab] 开头 显示规则 :: 说明如何生成一个或多个目标文件(包括 生成的文件, 文件的依赖文件, 生成的命令)隐晦规则 :: make的自动推导功能所执行的规则变量定义 :: Makefile中定义的变量文件指示 :: Makefile中引用其他Makefile; 指定Makefile中有效部分; 定义一个多行命令注释 :: Makefile只有行注释 “#”, 如果要使用或者输出”#”字符, 需要进行转义, “#“ GNU make 的工作方式读入主Makefile (主Makefile中可以引用其他Makefile)读入被include的其他Makefile初始化文件中的变量推导隐晦规则, 并分析所有规则为所有的目标文件创建依赖关系链根据依赖关系, 决定哪些目标要重新生成执行生成命令 Makefile 初级语法 Makefile 规则 规则语法规则主要有2部分: 依赖关系 和 生成目标的方法. 语法有以下2种: 123target ... : prerequisites ... command ... 或者 123target ... : prerequisites ; command command ... 注 command太长, 可以用 “&quot; 作为换行符 规则中的通配符 :: 表示任意一个或多个字符? :: 表示任意一个字符[…] :: ex. [abcd] 表示a,b,c,d中任意一个字符, [^abcd]表示除a,b,c,d以外的字符, [0-9]表示 0~9中任意一个数字~ :: 表示用户的home目录 路径搜索当一个Makefile中涉及到大量源文件时(这些源文件和Makefile极有可能不在同一个目录中), 这时, 最好将源文件的路径明确在Makefile中, 便于编译时查找. Makefile中有个特殊的变量 VPATH 就是完成这个功能的. 指定了 VPATH 之后, 如果当前目录中没有找到相应文件或依赖的文件, Makefile 回到 VPATH 指定的路径中再去查找.. VPATH 使用方法: vpath &lt;directories&gt; :: 当前目录中找不到文件时, 就从中搜索 vpath &lt;pattern&gt; &lt;directories&gt; :: 符合格式的文件, 就从中搜索 vpath &lt;pattern&gt; :: 清除符合格式的文件搜索路径 vpath :: 清除所有已经设置好的文件路径 复制代码 示例1 - 当前目录中找不到文件时, 按顺序从 src目录 ../parent-dir目录中查找文件1VPATH src:../parent-dir 示例2 - .h结尾的文件都从 ./header 目录中查找1VPATH %.h ./header 示例3 - 清除示例2中设置的规则1VPATH %.h 示例4 - 清除所有VPATH的设置1VPATH Makefile 中的变量 变量定义 ( = or := ) 12OBJS = programA.o programB.oOBJS-ADD = $(OBJS) programC.o 或者 12OBJS := programA.o programB.oOBJS-ADD := $(OBJS) programC.o 其中 = 和 := 的区别在于, := 只能使用前面定义好的变量, = 可以使用后面定义的变量 Makefile内容12OBJS2 = $(OBJS1) programC.oOBJS1 = programA.o programB.o 12all: @echo $(OBJS2) bash中执行 make, 可以看出虽然 OBJS1 是在 OBJS2 之后定义的, 但在 OBJS2中可以提前使用12$ makeprogramA.o programB.o programC.o Makefile内容12OBJS2 := $(OBJS1) programC.oOBJS1 := programA.o programB.o 12all: @echo $(OBJS2) bash中执行 make, 可以看出 OBJS2 中的 $(OBJS1) 为空12$ makeprogramC.o 变量替换Makefile内容 12SRCS := programA.c programB.c programC.cOBJS := $(SRCS:%.c=%.o) 123all: @echo "SRCS: " $(SRCS) @echo "OBJS: " $(OBJS) bash中运行make123$ makeSRCS: programA.c programB.c programC.cOBJS: programA.o programB.o programC.o 变量追加值 += Makefile内容12SRCS := programA.c programB.c programC.cSRCS += programD.c 12all: @echo "SRCS: " $(SRCS) bash中运行make12$ makeSRCS: programA.c programB.c programC.c programD.c 变量覆盖 override作用是使 Makefile中定义的变量能够覆盖 make 命令参数中指定的变量 语法: 123override &lt;variable&gt; = &lt;value&gt;override &lt;variable&gt; := &lt;value&gt;override &lt;variable&gt; += &lt;value&gt; 下面通过一个例子体会 override 的作用： Makefile内容 (没有用override)1234SRCS := programA.c programB.c programC.call: @echo "SRCS: " $(SRCS) bash中运行make12$ make SRCS=nothingSRCS: nothing Makefile内容 (用override)1override SRCS := programA.c programB.c programC.c all: @echo “SRCS: “ $(SRCS) bash中运行make12$ make SRCS=nothingSRCS: programA.c programB.c programC.c 目标变量作用是使变量的作用域仅限于这个目标(target), 而不像之前例子中定义的变量, 对整个Makefile都有效. 语法: 12&lt;target ...&gt; :: &lt;variable-assignment&gt;&lt;target ...&gt; :: override &lt;variable-assignment&gt; (override作用参见 变量覆盖的介绍) Makefile 内容12345678910SRCS := programA.c programB.c programC.ctarget1: TARGET1-SRCS := programD.ctarget1: @echo "SRCS: " $(SRCS) @echo "SRCS: " $(TARGET1-SRCS)target2: @echo "SRCS: " $(SRCS) @echo "SRCS: " $(TARGET1-SRCS) bash中执行make1234567$ make target1SRCS: programA.c programB.c programC.cSRCS: programD.c$ make target2 &lt;-- target2中显示不了 $(TARGET1-SRCS)SRCS: programA.c programB.c programC.cSRCS: Makefile 命令前缀Makefile 中书写shell命令时可以加2种前缀 @ 和 -, 或者不用前缀. 3种格式的shell命令区别如下: 不用前缀 :: 输出执行的命令以及命令执行的结果, 出错的话停止执行前缀 @ :: 只输出命令执行的结果, 出错的话停止执行前缀 - :: 命令执行有错的话, 忽略错误, 继续执行 Makefile 内容 (不用前缀)1234all: echo "没有前缀" cat this_file_not_exist echo "错误之后的命令" &lt;-- 这条命令不会被执行 bash中执行 make$ makeecho “没有前缀” &lt;– 命令本身显示出来没有前缀 &lt;– 命令执行结果显示出来cat this_file_not_existcat: this_file_not_exist: No such file or directorymake: *** [all] Error 1 ########################################################### Makefile 内容 (前缀 @)all: @echo “没有前缀” @cat this_file_not_exist @echo “错误之后的命令” &lt;– 这条命令不会被执行 bash中执行 make$ make没有前缀 &lt;– 只有命令执行的结果, 不显示命令本身cat: this_file_not_exist: No such file or directorymake: *** [all] Error 1 ########################################################### Makefile 内容 (前缀 -)all: -echo “没有前缀” -cat this_file_not_exist -echo “错误之后的命令” &lt;– 这条命令会被执行 bash中执行 make$ makeecho “没有前缀” &lt;– 命令本身显示出来没有前缀 &lt;– 命令执行结果显示出来cat this_file_not_existcat: this_file_not_exist: No such file or directorymake: [all] Error 1 (ignored)echo “错误之后的命令” &lt;– 出错之后的命令也会显示错误之后的命令 &lt;– 出错之后的命令也会执行复制代码 2.4 伪目标伪目标并不是一个”目标(target)”, 不像真正的目标那样会生成一个目标文件. 典型的伪目标是 Makefile 中用来清理编译过程中中间文件的 clean 伪目标, 一般格式如下: .PHONY: clean &lt;– 这句没有也行, 但是最好加上clean: -rm -f *.o 2.5 引用其他的 Makefile语法: include (filename 可以包含通配符和路径) 示例: 复制代码 Makefile 内容all: @echo “主 Makefile begin” @make other-all @echo “主 Makefile end” include ./other/Makefile ./other/Makefile 内容other-all: @echo “other makefile begin” @echo “other makefile end” bash中执行 make$ lltotal 20K-rw-r–r– 1 wangyubin wangyubin 125 Sep 23 16:13 Makefile-rw-r–r– 1 wangyubin wangyubin 11K Sep 23 16:15 makefile.org &lt;– 这个文件不用管drwxr-xr-x 2 wangyubin wangyubin 4.0K Sep 23 16:11 other$ ll other/total 4.0K-rw-r–r– 1 wangyubin wangyubin 71 Sep 23 16:11 Makefile $ make主 Makefile beginmake[1]: Entering directory /path/to/test/makefile&#39; other makefile begin other makefile end make[1]: Leaving directory/path/to/test/makefile’主 Makefile end复制代码 2.6 查看C文件的依赖关系写 Makefile 的时候, 需要确定每个目标的依赖关系. GNU提供一个机制可以查看C代码文件依赖那些文件, 这样我们在写 Makefile 目标的时候就不用打开C源码来看其依赖那些文件了. 比如, 下面命令显示内核源码中 virt/kvm/kvm_main.c 中的依赖关系 $ cd virt/kvm/$ gcc -MM kvm_main.ckvm_main.o: kvm_main.c iodev.h coalesced_mmio.h async_pf.h &lt;– 这句就可以加到 Makefile 中作为编译 kvm_main.o 的依赖关系 2.7 make 退出码Makefile的退出码有以下3种： 0 :: 表示成功执行1 :: 表示make命令出现了错误2 :: 使用了 “-q” 选项, 并且make使得一些目标不需要更新 2.8 指定 Makefile， 指定特定目标默认执行 make 命令时, GNU make在当前目录下依次搜索下面3个文件 “GNUmakefile”, “makefile”, “Makefile”, 找到对应文件之后, 就开始执行此文件中的第一个目标(target). 如果找不到这3个文件就报错. 非默认情况下, 可以在 make 命令中指定特定的 Makefile 和特定的 目标. 示例： 复制代码 Makefile文件名改为 MyMake, 内容target1: @echo “target [1] begin” @echo “target [1] end” target2: @echo “target [2] begin” @echo “target [2] end” bash 中执行 make$ lsMakefile$ mv Makefile MyMake$ lsMyMake$ make &lt;– 找不到默认的 Makefilemake: *** No targets specified and no makefile found. Stop.$ make -f MyMake &lt;– 指定特定的Makefiletarget [1] begintarget [1] end$ make -f MyMake target2 &lt;– 指定特定的目标(target)target [2] begintarget [2] end复制代码 2.9 make 参数介绍make 的参数有很多, 可以通过 make -h 去查看, 下面只介绍几个我认为比较有用的. 参数 含义 –debug[=] 输出make的调试信息, options 可以是 a, b, v-j –jobs 同时运行的命令的个数, 也就是多线程执行 Makefile-r –no-builtin-rules 禁止使用任何隐含规则-R –no-builtin-variabes 禁止使用任何作用于变量上的隐含规则-B –always-make 假设所有目标都有更新, 即强制重编译 2.10 Makefile 隐含规则这里只列一个和编译C相关的. 编译C时，.o 的目标会自动推导为 .c 复制代码 Makefile 中main : main.o gcc -o main main.o #会自动变为:main : main.o gcc -o main main.o main.o: main.c &lt;– main.o 这个目标是隐含生成的 gcc -c main.c复制代码 2.11 隐含规则中的 命令变量 和 命令参数变量2.11.1 命令变量, 书写Makefile可以直接写 shell时用这些变量.下面只列出一些C相关的 变量名 含义 RM rm -fAR arCC ccCXX g++示例: 复制代码 Makefile 内容all: @echo $(RM) @echo $(AR) @echo $(CC) @echo $(CXX) bash 中执行make, 显示各个变量的值$ makerm -farccg++复制代码 2.11.2 命令参数变量变量名 含义 ARFLAGS AR命令的参数CFLAGS C语言编译器的参数CXXFLAGS C++语言编译器的参数 示例: 下面以 CFLAGS 为例演示 复制代码 test.c 内容#include &lt;stdio.h&gt; int main(int argc, char *argv[]){ printf (“Hello Makefile\n”); return 0;} Makefile 内容test: test.o $(CC) -o test test.o bash 中用 make 来测试$ lltotal 24K-rw-r–r– 1 wangyubin wangyubin 69 Sep 23 17:31 Makefile-rw-r–r– 1 wangyubin wangyubin 14K Sep 23 19:51 makefile.org &lt;– 请忽略这个文件-rw-r–r– 1 wangyubin wangyubin 392 Sep 23 17:31 test.c $ makecc -c -o test.o test.ccc -o test test.o &lt;– 这个是自动推导的 $ rm -f test test.o $ make CFLAGS=-Wall &lt;– 命令中加的编译器参数自动追加入下面的编译中了cc -Wall -c -o test.o test.ccc -o test test.o复制代码 2.12 自动变量Makefile 中很多时候通过自动变量来简化书写, 各个自动变量的含义如下: 自动变量 含义 $@ 目标集合$% 当目标是函数库文件时, 表示其中的目标文件名$&lt; 第一个依赖目标. 如果依赖目标是多个, 逐个表示依赖目标$? 比目标新的依赖目标的集合$^ 所有依赖目标的集合, 会去除重复的依赖目标$+ 所有依赖目标的集合, 不会去除重复的依赖目标$* 这个是GNU make特有的, 其它的make不一定支持 Makefile 高级语法 1 嵌套Makefile在 Makefile 初级语法中已经提到过引用其它 Makefile的方法. 这里有另一种写法, 并且可以向引用的其它 Makefile 传递参数. 示例: (不传递参数, 只是调用子文件夹 other 中的Makefile) 复制代码 Makefile 内容all: @echo “主 Makefile begin” @cd ./other &amp;&amp; make @echo “主 Makefile end” ./other/Makefile 内容other-all: @echo “other makefile begin” @echo “other makefile end” bash中执行 make$ lltotal 28K-rw-r–r– 1 wangyubin wangyubin 104 Sep 23 20:43 Makefile-rw-r–r– 1 wangyubin wangyubin 17K Sep 23 20:44 makefile.org &lt;– 这个文件不用管drwxr-xr-x 2 wangyubin wangyubin 4.0K Sep 23 20:42 other$ ll other/total 4.0K-rw-r–r– 1 wangyubin wangyubin 71 Sep 23 16:11 Makefile $ make主 Makefile beginmake[1]: Entering directory /path/to/test/makefile/other&#39; other makefile begin other makefile end make[1]: Leaving directory/path/to/test/makefile/other’主 Makefile end复制代码 示例: (用export传递参数) 复制代码 Makefile 内容export VALUE1 := export.c &lt;– 用了 export, 此变量能够传递到 ./other/Makefile 中VALUE2 := no-export.c &lt;– 此变量不能传递到 ./other/Makefile 中 all: @echo “主 Makefile begin” @cd ./other &amp;&amp; make @echo “主 Makefile end” ./other/Makefile 内容other-all: @echo “other makefile begin” @echo “VALUE1: “ $(VALUE1) @echo “VALUE2: “ $(VALUE2) @echo “other makefile end” bash中执行 make$ make主 Makefile beginmake[1]: Entering directory /path/to/test/makefile/other&#39; other makefile begin VALUE1: export.c &lt;-- VALUE1 传递成功 VALUE2: &lt;-- VALUE2 传递失败 other makefile end make[1]: Leaving directory/path/to/test/makefile/other’主 Makefile end复制代码 补充 export 语法格式如下: export variable = valueexport variable := valueexport variable += value 3.2 定义命令包命令包有点像是个函数, 将连续的相同的命令合成一条, 减少 Makefile 中的代码量, 便于以后维护. 语法: define command…endef 示例: 复制代码 Makefile 内容define run-hello-makefile@echo -n “Hello”@echo “ Makefile!”@echo “这里可以执行多条 Shell 命令!”endef all: $(run-hello-makefile) bash 中运行make$ makeHello Makefile!这里可以执行多条 Shell 命令!复制代码 3.3 条件判断条件判断的关键字主要有 ifeq ifneq ifdef ifndef 语法: 复制代码endif 或者 else endif 复制代码 示例: ifeq的例子, ifneq和ifeq的使用方法类似, 就是取反 复制代码 Makefile 内容all:ifeq (“aa”, “bb”) @echo “equal”else @echo “not equal”endif bash 中执行 make$ makenot equal复制代码 示例: ifdef的例子, ifndef和ifdef的使用方法类似, 就是取反 复制代码 Makefile 内容SRCS := program.c all:ifdef SRCS @echo $(SRCS)else @echo “no SRCS”endif bash 中执行 make$ makeprogram.c复制代码 3.4 Makefile 中的函数Makefile 中自带了一些函数, 利用这些函数可以简化 Makefile 的编写. 函数调用语法如下: $( ) 或者${ } 是函数名 是函数参数 3.4.1 字符串函数字符串替换函数: $(subst ,,) 功能: 把字符串 中的 替换为 返回: 替换过的字符串 复制代码 Makefile 内容all: @echo $(subst t,e,maktfilt) &lt;– 将t替换为e bash 中执行 make$ makemakefile复制代码 模式字符串替换函数: $(patsubst ,,) 功能: 查找中的单词(单词以”空格”, “tab”, “换行”来分割) 是否符合 , 符合的话, 用 替代. 返回: 替换过的字符串 复制代码 Makefile 内容all: @echo $(patsubst %.c,%.o,programA.c programB.c) bash 中执行 make$ makeprogramA.o programB.o复制代码 去空格函数: $(strip ) 功能: 去掉 字符串中开头和结尾的空字符 返回: 被去掉空格的字符串值 复制代码 Makefile 内容VAL := “ aa bb cc “ all: @echo “去除空格前: “ $(VAL) @echo “去除空格后: “ $(strip $(VAL)) bash 中执行 make$ make去除空格前: aa bb cc去除空格后: aa bb cc复制代码 查找字符串函数: $(findstring ,) 功能: 在字符串 中查找 字符串 返回: 如果找到, 返回 字符串, 否则返回空字符串 复制代码 Makefile 内容VAL := “ aa bb cc “ all: @echo $(findstring aa,$(VAL)) @echo $(findstring ab,$(VAL)) bash 中执行 make$ makeaa复制代码 过滤函数: $(filter &lt;pattern…&gt;,) 功能: 以 模式过滤字符串 , 保留 符合模式 的单词, 可以有多个模式 返回: 符合模式 的字符串 复制代码 Makefile 内容all: @echo $(filter %.o %.a,program.c program.o program.a) bash 中执行 make$ makeprogram.o program.a复制代码 反过滤函数: $(filter-out &lt;pattern…&gt;,) 功能: 以 模式过滤字符串 , 去除 符合模式 的单词, 可以有多个模式 返回: 不符合模式 的字符串 复制代码 Makefile 内容all: @echo $(filter-out %.o %.a,program.c program.o program.a) bash 中执行 make$ makeprogram.c复制代码 排序函数: $(sort ) 功能: 给字符串 中的单词排序 (升序) 返回: 排序后的字符串 复制代码 Makefile 内容all: @echo $(sort bac abc acb cab) bash 中执行 make$ makeabc acb bac cab复制代码 取单词函数: $(word ,) 功能: 取字符串 中的 第个单词 (n从1开始) 返回: 中的第个单词, 如果 比 中单词个数要大, 则返回空字符串 复制代码 Makefile 内容all: @echo $(word 1,aa bb cc dd) @echo $(word 5,aa bb cc dd) @echo $(word 4,aa bb cc dd) bash 中执行 make$ makeaa dd复制代码 取单词串函数: $(wordlist ,,) 功能: 从字符串中取从开始到的单词串. 和是一个数字. 返回: 从到的字符串 复制代码 Makefile 内容all: @echo $(wordlist 1,3,aa bb cc dd) @echo $(word 5,6,aa bb cc dd) @echo $(word 2,5,aa bb cc dd) bash 中执行 make$ makeaa bb cc bb复制代码 单词个数统计函数: $(words ) 功能: 统计字符串 中单词的个数 返回: 单词个数 复制代码 Makefile 内容all: @echo $(words aa bb cc dd) @echo $(words aabbccdd) @echo $(words ) bash 中执行 make$ make410复制代码 首单词函数: $(firstword ) 功能: 取字符串 中的第一个单词 返回: 字符串 中的第一个单词 复制代码 Makefile 内容all: @echo $(firstword aa bb cc dd) @echo $(firstword aabbccdd) @echo $(firstword ) bash 中执行 make$ makeaaaabbccdd复制代码 3.4.2 文件名函数取目录函数: $(dir &lt;names…&gt;) 功能: 从文件名序列 中取出目录部分 返回: 文件名序列 中的目录部分 复制代码 Makefile 内容all: @echo $(dir /home/a.c ./bb.c ../c.c d.c) bash 中执行 make$ make/home/ ./ ../ ./复制代码 取文件函数: $(notdir &lt;names…&gt;) 功能: 从文件名序列 中取出非目录部分 返回: 文件名序列 中的非目录部分 复制代码 Makefile 内容all: @echo $(notdir /home/a.c ./bb.c ../c.c d.c) bash 中执行 make$ makea.c bb.c c.c d.c复制代码 取后缀函数: $(suffix &lt;names…&gt;) 功能: 从文件名序列 中取出各个文件名的后缀 返回: 文件名序列 中各个文件名的后缀, 没有后缀则返回空字符串 复制代码 Makefile 内容all: @echo $(suffix /home/a.c ./b.o ../c.a d) bash 中执行 make$ make.c .o .a复制代码 取前缀函数: $(basename &lt;names…&gt;) 功能: 从文件名序列 中取出各个文件名的前缀 返回: 文件名序列 中各个文件名的前缀, 没有前缀则返回空字符串 复制代码 Makefile 内容all: @echo $(basename /home/a.c ./b.o ../c.a /home/.d .e) bash 中执行 make$ make/home/a ./b ../c /home/复制代码 加后缀函数: $(addsuffix ,&lt;names…&gt;) 功能: 把后缀 加到 中的每个单词后面 返回: 加过后缀的文件名序列 复制代码 Makefile 内容all: @echo $(addsuffix .c,/home/a b ./c.o ../d.c) bash 中执行 make$ make/home/a.c b.c ./c.o.c ../d.c.c复制代码 加前缀函数: $(addprefix ,&lt;names…&gt;) 功能: 把前缀 加到 中的每个单词前面 返回: 加过前缀的文件名序列 复制代码 Makefile 内容all: @echo $(addprefix test_,/home/a.c b.c ./d.c) bash 中执行 make$ maketest_/home/a.c test_b.c test_./d.c复制代码 连接函数: $(join ,) 功能: 中对应的单词加到 后面 返回: 连接后的字符串 复制代码 Makefile 内容all: @echo $(join a b c d,1 2 3 4) @echo $(join a b c d,1 2 3 4 5) @echo $(join a b c d e,1 2 3 4) bash 中执行 make$ makea1 b2 c3 d4a1 b2 c3 d4 5a1 b2 c3 d4 e复制代码 3.4.3 foreach语法: $(foreach ,,) 示例: 复制代码 Makefile 内容targets := a b c dobjects := $(foreach i,$(targets),$(i).o) all: @echo $(targets) @echo $(objects) bash 中执行 make$ makea b c da.o b.o c.o d.o复制代码 3.4.4 if这里的if是个函数, 和前面的条件判断不一样, 前面的条件判断属于Makefile的关键字 语法: $(if ,) $(if ,,) 示例: 复制代码 Makefile 内容val := aobjects := $(if $(val),$(val).o,nothing)no-objects := $(if $(no-val),$(val).o,nothing) all: @echo $(objects) @echo $(no-objects) bash 中执行 make$ makea.onothing复制代码 3.4.5 call - 创建新的参数化函数语法: $(call ,,,…) 示例: 复制代码 Makefile 内容log = “====debug====” $(1) “====end====” all: @echo $(call log,”正在 Make”) bash 中执行 make$ make====debug==== 正在 Make ====end====复制代码 3.4.6 origin - 判断变量的来源语法: $(origin ) 返回值有如下类型: 类型 含义 undefined 没有定义过default 是个默认的定义, 比如 CC 变量environment 是个环境变量, 并且 make时没有使用 -e 参数file 定义在Makefile中command line 定义在命令行中override 被 override 重新定义过automatic 是自动化变量 示例: 复制代码 Makefile 内容val-in-file := test-fileoverride val-override := test-override all: @echo $(origin not-define) # not-define 没有定义 @echo $(origin CC) # CC 是Makefile默认定义的变量 @echo $(origin PATH) # PATH 是 bash 环境变量 @echo $(origin val-in-file) # 此Makefile中定义的变量 @echo $(origin val-in-cmd) # 这个变量会加在 make 的参数中 @echo $(origin val-override) # 此Makefile中定义的override变量 @echo $(origin @) # 自动变量, 具体前面的介绍 bash 中执行 make$ make val-in-cmd=val-cmdundefineddefaultenvironmentfilecommand lineoverrideautomatic复制代码 3.4.7 shell语法: $(shell ) 它的作用就是执行一个shell命令, 并将shell命令的结果作为函数的返回. 作用和 &lt;shell command&gt; 一样, ` 是反引号 3.4.8 make 控制函数产生一个致命错误: $(error &lt;text …&gt;) 功能: 输出错误信息, 停止Makefile的运行 复制代码 Makefile 内容all: $(error there is an error!) @echo “这里不会执行!” bash 中执行 make$ makeMakefile:2: *** there is an error!. Stop.复制代码 输出警告: $(warning &lt;text …&gt;) 功能: 输出警告信息, Makefile继续运行 复制代码 Makefile 内容all: $(warning there is an warning!) @echo “这里会执行!” bash 中执行 make$ makeMakefile:2: there is an warning!这里会执行!复制代码 3.5 Makefile中一些GNU约定俗成的伪目标如果有过在Linux上, 从源码安装软件的经历的话, 就会对 make clean, make install 比较熟悉. 像 clean, install 这些伪目标, 广为人知 下面列举一些常用的伪目标, 如果在自己项目的Makefile合理使用这些伪目标的话, 可以让我们自己的Makefile看起来更专业, 呵呵 :) 含义 all 所有目标的目标，其功能一般是编译所有的目标clean 删除所有被make创建的文件install 安装已编译好的程序，其实就是把目标可执行文件拷贝到指定的目录中去print 列出改变过的源文件tar 把源程序打包备份. 也就是一个tar文件dist 创建一个压缩文件, 一般是把tar文件压成Z文件. 或是gz文件TAGS 更新所有的目标, 以备完整地重编译使用check 或 test 一般用来测试makefile的流程]]></content>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LIS]]></title>
    <url>%2F2019%2F09%2F29%2FLIS%2F</url>
    <content type="text"><![CDATA[LIS n^2 dp 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 40005;int a[maxn];int dp[maxn];int main()&#123; int n; scanf("%d",&amp;n); for( int i=0; i&lt;n; i++ )&#123; scanf("%d",a+i); &#125; int ans=0; for( int i=0; i&lt;n; i++ )&#123; dp[i]=1; for( int j=0; j&lt;i; j++ )&#123; if(a[j]&lt;a[i])&#123; dp[i]=max(dp[i],dp[j]+1); &#125; &#125; ans=max(ans,dp[i]); &#125; printf("%d",ans); return 0;&#125; nlogn 二分LIS的nlogn的优化：LIS的优化说白了其实是贪心算法，比如说让你求一个最长上升子序列把，一起走一遍。 比如说（4, 2, 3, 1, 2，3，5）这个序列，求他的最长上升子序列，那么来看，如果求最长的上升序列，那么按照贪心，应该最可能的让该序列的元素整体变小，以便可以加入更多的元素。现在开辟一个新的数组，arr[ 10 ]， { …….} –&gt; 这个是他的空间 ，现在开始模拟贪心算法求解最长上升子序列，第一个数是4，先加进去，那么为{ 4 }再来看下一个数2，它比4小，所以如果他与4替换是不是可以让目前子序列（他这一个元素组成的子序列）变得更小，更方便以后元素的加入呢？是的。所以现在为{ 2 } 再来看他的下一个元素3，他要比2大，所以呢加在他的后面，{ 2, 3}再看下一个元素是1，它比3要小，所以呢为了保证子序列整体尽可能的小（以便可以加入更多的元素），从目前的序列中查找出第一个比他大的数替换掉，那么就变成了{ 1， 3}，继续。。 下一个数是2，那么序列变为{ 1，2}，再下一个数为3，那么序列为{1，2，3}，在下一个数为5，那么序列为{1，2，3，5}，完。 目前序列里又4个元素，所以他的最长子序列的个数为4，但是这个序列是一个伪序列，里面的元素，并不是真正的最长上升子序列，而仅仅和最长上升子序列的个数一样。因为查找的时候用的二分查找，所以时间复杂度为o（nlogn）。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int arr[500],n,dp[500]; scanf("%d",&amp;n); for( int i=1; i&lt;=n; i++ )&#123; scanf("%d",&amp;arr[i]); &#125; int k=1; dp[k]=arr[1]; for( int i=2; i&lt;=n; i++ )&#123; if(arr[i]&gt;dp[k]) dp[++k]=arr[i]; else *lower_bound(dp+1,dp+1+k,arr[i])=arr[i]; &#125; printf("%d\n",k); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方舟编译器编译及其执行]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%96%B9%E8%88%9F%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[华为开发者相关网站 华为鸿蒙系统开发者论坛 华为开发者联盟 方舟编译器 华为 DevEco Studio 华为开源平台 华为云 华为应用市场 方舟编译器编译 环境准备 开发环境推荐您需要安装一个64位版本的Ubuntu（推荐Ubuntu 16.04） 12sudo apt-get -y install openjdk-8-jdk git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip lib32z1-dev qemu g++-multilib gcc-multilib libglib2.0-dev libpixman-1-dev linux-libc-dev:i386sudo apt-get -y install gcc-5-aarch64-linux-gnu g++-5-aarch64-linux-gnu 安装Clang编译器并完成配置（用于编译方舟编译器代码）下载clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04LLVM下载地址：LLVM放置到openarkcompiler/tools目录，打开openarkcompiler/build/config/BUILDCONFIG.gn文件，将GN_C_COMPILER、GN_CXX_COMPILER和GN_AR_COMPILER三个变量配置为Clang编译器所在路径，例如： 123GN_C_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang&quot;GN_CXX_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang++&quot;GN_AR_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/llvm-ar&quot; 其中${MAPLE_ROOT}为openarkcompiler源码根目录。 安装Ninja、GN并完成配置下载Ninja(v1.9.0)及GN(Linux Version)Ninja下载地址：NinjaGN下载地址：gn将GN和Ninja可执行程序放置到openarkcompiler/tools目录，打开openarkcompiler/Makefile文件，将GN和NINJA两个变量配置为GN和Ninja可执行程序所在路径。例如：12GN := $&#123;MAPLE_ROOT&#125;/tools/gn/gnNINJA := $&#123;MAPLE_ROOT&#125;/tools/ninja_1.9.0/ninja 编译器编译 源码下载下载地址：源码可以通过Clone or Download的方式下载openarkcompiler 源码注：默认源码下载目录为openarkcompiler源码编译在openarkcompiler目录下执行以下命令，编译出OpenArkCompiler，默认输出路径 openarkcompiler/out/bin。 12source build/envsetup.shmake 命令说明：source build/envsetup.sh 初始化环境，将OpenArkCompiler工具链路径openarkcompiler/src/bin设置到环境变量中make 编译OpenArkCompiler的Release版本make BUILD_TYPE=DEBUG 编译OpenArkCompiler的Debug版本 编译结果展示 方舟编译器执行过程 在博主跑helloworld的过程中，发现抱错显示少java-core.jar包，在几经周折后在码云上找到了jar包,java-core.jar地址. 在openarkcompiler文件夹下新建文件夹libjava-core，将jar包拷贝至目录下 在openarkcompiler目录下执行 1source build/envsetup.sh cd 至samples文件夹下的helloworld 执行 1make 执行其他samples样例如图所示（在执行过程中找了一个杨辉三角的java代码，跑了一下)]]></content>
      <tags>
        <tag>方舟编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH,公钥,私钥的理解]]></title>
    <url>%2F2019%2F09%2F25%2FSSH-%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先我们需要区分加密和认证这两个基本概念。 加密是将数据资料加密，使得非法用户即使取得加密过的资料，也无法获取正确的资料内容，所以数据加密可以保护数据，防止监听攻击。其重点在于数据的安全性。身份认证是用来判断某个身份的真实性，确认身份后，系统才可以依不同的身份给予不同的权限。其重点在于用户的真实性。两者的侧重点是不同的。 公钥和私钥其次我们还要了解公钥和私钥的概念和作用。 在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是非对称密钥密码系统，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。 公钥私钥的原则：一个公钥对应一个私钥。密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 非对称密钥密码的主要应用就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的，下面我就详细讲解一下两者的区别。 基于公开密钥的加密过程 比如有两个用户Alice和Bob，Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下： Bob将他的公开密钥传送给Alice。 Alice用Bob的公开密钥加密她的消息，然后传送给Bob。 Bob用他的私人密钥解密Alice的消息。 上面的过程可以用下图表示，Alice使用Bob的公钥进行加密，Bob用自己的私钥进行解密。 基于公开密钥的认证过程 身份认证和加密就不同了，主要用户鉴别用户的真伪。这里我们只要能够鉴别一个用户的私钥是正确的，就可以鉴别这个用户的真伪。 还是Alice和Bob这两个用户，Alice想让Bob知道自己是真实的Alice，而不是假冒的，因此Alice只要使用公钥密码学对文件签名发送给Bob，Bob使用Alice的公钥对文件进行解密，如果可以解密成功，则证明Alice的私钥是正确的，因而就完成了对Alice的身份鉴别。整个身份认证的过程如下： Alice用她的私人密钥对文件加密，从而对文件签名。 Alice将签名的文件传送给Bob。 Bob用Alice的公钥解密文件，从而验证签名。 上面的过程可以用下图表示，Alice使用自己的私钥加密，Bob用Alice的公钥进行解密。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地项目恢复]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[今天在从本地仓库推送到github的过程中由于操作不当，导致本地代码被覆盖。瞬间泪崩。一度以为自己写了好几天的代码就断送了。不过一想到git是分布式的，本身就是因为版本控制而开发的呀，所以一定有办法恢复以前版本。方法如下： 查看以往版本号git reflog 找到想要恢复的版本号(黄色)git reset --hard 版本号]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地仓库更新至github]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%9B%B4%E6%96%B0%E8%87%B3github%2F</url>
    <content type="text"><![CDATA[git本地仓库更新至github 右键需要更新的项目 git add .(注意这里有一个空格) git commit -m &quot;更新信息&quot; git remote rm origin &#39;git remote add origin ssh或者HTTPS地址 git push -u origin master/mastercpp 如果推送不成功的话，肯能是本地项目缺少README.md文件，在保证安全的情况下，可以考虑强推 git push -f origin master/mastercpp]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
