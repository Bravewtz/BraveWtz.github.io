<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LIS]]></title>
    <url>%2F2019%2F09%2F29%2FLIS%2F</url>
    <content type="text"><![CDATA[LIS n^2 dp 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 40005;int a[maxn];int dp[maxn];int main()&#123; int n; scanf("%d",&amp;n); for( int i=0; i&lt;n; i++ )&#123; scanf("%d",a+i); &#125; int ans=0; for( int i=0; i&lt;n; i++ )&#123; dp[i]=1; for( int j=0; j&lt;i; j++ )&#123; if(a[j]&lt;a[i])&#123; dp[i]=max(dp[i],dp[j]+1); &#125; &#125; ans=max(ans,dp[i]); &#125; printf("%d",ans); return 0;&#125; nlogn 二分LIS的nlogn的优化：LIS的优化说白了其实是贪心算法，比如说让你求一个最长上升子序列把，一起走一遍。 比如说（4, 2, 3, 1, 2，3，5）这个序列，求他的最长上升子序列，那么来看，如果求最长的上升序列，那么按照贪心，应该最可能的让该序列的元素整体变小，以便可以加入更多的元素。现在开辟一个新的数组，arr[ 10 ]， { …….} –&gt; 这个是他的空间 ，现在开始模拟贪心算法求解最长上升子序列，第一个数是4，先加进去，那么为{ 4 }再来看下一个数2，它比4小，所以如果他与4替换是不是可以让目前子序列（他这一个元素组成的子序列）变得更小，更方便以后元素的加入呢？是的。所以现在为{ 2 } 再来看他的下一个元素3，他要比2大，所以呢加在他的后面，{ 2, 3}再看下一个元素是1，它比3要小，所以呢为了保证子序列整体尽可能的小（以便可以加入更多的元素），从目前的序列中查找出第一个比他大的数替换掉，那么就变成了{ 1， 3}，继续。。 下一个数是2，那么序列变为{ 1，2}，再下一个数为3，那么序列为{1，2，3}，在下一个数为5，那么序列为{1，2，3，5}，完。 目前序列里又4个元素，所以他的最长子序列的个数为4，但是这个序列是一个伪序列，里面的元素，并不是真正的最长上升子序列，而仅仅和最长上升子序列的个数一样。因为查找的时候用的二分查找，所以时间复杂度为o（nlogn）。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int arr[500],n,dp[500]; scanf("%d",&amp;n); for( int i=1; i&lt;=n; i++ )&#123; scanf("%d",&amp;arr[i]); &#125; int k=1; dp[k]=arr[1]; for( int i=2; i&lt;=n; i++ )&#123; if(arr[i]&gt;dp[k]) dp[++k]=arr[i]; else *lower_bound(dp+1,dp+1+k,arr[i])=arr[i]; &#125; printf("%d\n",k); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分专题]]></title>
    <url>%2F2019%2F09%2F29%2F%E4%BA%8C%E5%88%86%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[二分搜索二分搜索是通过不断缩小解可能存在的范围，从而求解问题的最优解的方法 常用算法模板 1234567891011121314151617181920//整数二分int left = 0,ri =maxn;int ans = -1;while (left &lt;= ri)&#123; int mid = (left + ri)/2; if( check(mid) ) ans=mid,left = mid+1; else ri= mid-1;&#125;cout &lt;&lt; ans &lt;&lt;endl;//double型二分double left = 0,ri =maxn;double ans = 0;for(int i=0; i&lt;100; i++)&#123; double mid = (left + ri)/2.0; if(check (mid)) ans = mid, le = mid; else ri = mid;&#125;cout&lt;&lt; ans &lt;&lt;endl; 最大化最小值例题：poj2456分析：类似的最大化最小值或者最小化最大值的问题可以使用二分搜索算法得以实现，此题我们可以定义C(d):=可以安排牛的位置是的最近的两头牛的位置不小于d.,那么为问题就转化为求满足C(d)的最大位置的d.使用贪心 对牛舍的位置进行排序 把第一头牛放入x0的牛舍 如果第i头牛放入了xj的话，第i+1头牛就要放入满足xj+d&lt;=xk的最小的xk中 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std;#define LL long long#define INF 0x3f3f3f3fconst int maxn = 1e5+10;int x[maxn];int n,m;int check(int d)&#123; int cnt=1,temp=x[0]; for(int i=1; i&lt;n; i++ )if(x[i]-temp&gt;=d)&#123; cnt++; temp=x[i]; if(cnt==m) return 1; &#125; return 0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for( int i=0; i&lt;n; i++ ) scanf("%d",&amp;x[i]); sort(x,x+n); int l=0,r=x[n-1]-x[0]; int ans=0; while(l&lt;=r)&#123; int mid=l+(r-l)/2; if(check(mid)) &#123; ans=mid; l=mid+1; &#125; else&#123; r=mid-1; &#125; &#125; printf("%d\n",ans); return 0;&#125; 最大化平均值略]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方舟编译器编译及其执行]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%96%B9%E8%88%9F%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[华为开发者相关网站 华为鸿蒙系统开发者论坛 华为开发者联盟 方舟编译器 华为 DevEco Studio 华为开源平台 华为云 华为应用市场 方舟编译器编译 环境准备 开发环境推荐您需要安装一个64位版本的Ubuntu（推荐Ubuntu 16.04） 12sudo apt-get -y install openjdk-8-jdk git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip lib32z1-dev qemu g++-multilib gcc-multilib libglib2.0-dev libpixman-1-dev linux-libc-dev:i386sudo apt-get -y install gcc-5-aarch64-linux-gnu g++-5-aarch64-linux-gnu 安装Clang编译器并完成配置（用于编译方舟编译器代码）下载clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04LLVM下载地址：LLVM放置到openarkcompiler/tools目录，打开openarkcompiler/build/config/BUILDCONFIG.gn文件，将GN_C_COMPILER、GN_CXX_COMPILER和GN_AR_COMPILER三个变量配置为Clang编译器所在路径，例如： 123GN_C_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang&quot;GN_CXX_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang++&quot;GN_AR_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/llvm-ar&quot; 其中${MAPLE_ROOT}为openarkcompiler源码根目录。 安装Ninja、GN并完成配置下载Ninja(v1.9.0)及GN(Linux Version)Ninja下载地址：NinjaGN下载地址：gn将GN和Ninja可执行程序放置到openarkcompiler/tools目录，打开openarkcompiler/Makefile文件，将GN和NINJA两个变量配置为GN和Ninja可执行程序所在路径。例如：12GN := $&#123;MAPLE_ROOT&#125;/tools/gn/gnNINJA := $&#123;MAPLE_ROOT&#125;/tools/ninja_1.9.0/ninja 编译器编译 源码下载下载地址：源码可以通过Clone or Download的方式下载openarkcompiler 源码注：默认源码下载目录为openarkcompiler源码编译在openarkcompiler目录下执行以下命令，编译出OpenArkCompiler，默认输出路径 openarkcompiler/out/bin。 12source build/envsetup.shmake 命令说明：source build/envsetup.sh 初始化环境，将OpenArkCompiler工具链路径openarkcompiler/src/bin设置到环境变量中make 编译OpenArkCompiler的Release版本make BUILD_TYPE=DEBUG 编译OpenArkCompiler的Debug版本 编译结果展示 方舟编译器执行过程 在博主跑helloworld的过程中，发现抱错显示少java-core.jar包，在几经周折后在码云上找到了jar包,java-core.jar地址. 在openarkcompiler文件夹下新建文件夹libjava-core，将jar包拷贝至目录下 在openarkcompiler目录下执行 1source build/envsetup.sh cd 至samples文件夹下的helloworld 执行 1make 执行其他samples样例如图所示（在执行过程中找了一个杨辉三角的java代码，跑了一下)]]></content>
      <tags>
        <tag>方舟编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH,公钥,私钥的理解]]></title>
    <url>%2F2019%2F09%2F25%2FSSH-%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先我们需要区分加密和认证这两个基本概念。 加密是将数据资料加密，使得非法用户即使取得加密过的资料，也无法获取正确的资料内容，所以数据加密可以保护数据，防止监听攻击。其重点在于数据的安全性。身份认证是用来判断某个身份的真实性，确认身份后，系统才可以依不同的身份给予不同的权限。其重点在于用户的真实性。两者的侧重点是不同的。 公钥和私钥其次我们还要了解公钥和私钥的概念和作用。 在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是非对称密钥密码系统，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。 公钥私钥的原则：一个公钥对应一个私钥。密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 非对称密钥密码的主要应用就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的，下面我就详细讲解一下两者的区别。 基于公开密钥的加密过程 比如有两个用户Alice和Bob，Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下： Bob将他的公开密钥传送给Alice。 Alice用Bob的公开密钥加密她的消息，然后传送给Bob。 Bob用他的私人密钥解密Alice的消息。 上面的过程可以用下图表示，Alice使用Bob的公钥进行加密，Bob用自己的私钥进行解密。 基于公开密钥的认证过程 身份认证和加密就不同了，主要用户鉴别用户的真伪。这里我们只要能够鉴别一个用户的私钥是正确的，就可以鉴别这个用户的真伪。 还是Alice和Bob这两个用户，Alice想让Bob知道自己是真实的Alice，而不是假冒的，因此Alice只要使用公钥密码学对文件签名发送给Bob，Bob使用Alice的公钥对文件进行解密，如果可以解密成功，则证明Alice的私钥是正确的，因而就完成了对Alice的身份鉴别。整个身份认证的过程如下： Alice用她的私人密钥对文件加密，从而对文件签名。 Alice将签名的文件传送给Bob。 Bob用Alice的公钥解密文件，从而验证签名。 上面的过程可以用下图表示，Alice使用自己的私钥加密，Bob用Alice的公钥进行解密。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地项目恢复]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[今天在从本地仓库推送到github的过程中由于操作不当，导致本地代码被覆盖。瞬间泪崩。一度以为自己写了好几天的代码就断送了。不过一想到git是分布式的，本身就是因为版本控制而开发的呀，所以一定有办法恢复以前版本。方法如下： 查看以往版本号git reflog 找到想要恢复的版本号(黄色)git reset --hard 版本号]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地仓库更新至github]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%9B%B4%E6%96%B0%E8%87%B3github%2F</url>
    <content type="text"><![CDATA[git本地仓库更新至github 右键需要更新的项目 git add .(注意这里有一个空格) git commit -m &quot;更新信息&quot; git remote rm origin &#39;git remote add origin ssh或者HTTPS地址 git push -u origin master/mastercpp 如果推送不成功的话，肯能是本地项目缺少README.md文件，在保证安全的情况下，可以考虑强推 git push -f origin master/mastercpp]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
