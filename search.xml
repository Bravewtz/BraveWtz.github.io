<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Makefile简介]]></title>
    <url>%2F2019%2F10%2F05%2FMakefile%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Makefile 简介Makefile 是和 make 命令一起配合使用的.很多大型项目的编译都是通过 Makefile 来组织的, 如果没有 Makefile, 那很多项目中各种库和代码之间的依赖关系不知会多复杂.Makefile的组织流程的能力如此之强, 不仅可以用来编译项目, 还可以用来组织我们平时的一些日常操作. 这个需要大家发挥自己的想象力. Makefile 主要的 5个部分 (显示规则, 隐晦规则, 变量定义, 文件指示, 注释)Makefile基本格式如下: 1234target ... : prerequisites ... command ... ... 其中, target - 目标文件, 可以是 Object File, 也可以是可执行文件prerequisites - 生成 target 所需要的文件或者目标command - make需要执行的命令 (任意的shell命令), Makefile中的命令必须以 [tab] 开头 显示规则 :: 说明如何生成一个或多个目标文件(包括 生成的文件, 文件的依赖文件, 生成的命令)隐晦规则 :: make的自动推导功能所执行的规则变量定义 :: Makefile中定义的变量文件指示 :: Makefile中引用其他Makefile; 指定Makefile中有效部分; 定义一个多行命令注释 :: Makefile只有行注释 “#”, 如果要使用或者输出”#”字符, 需要进行转义, “#“ GNU make 的工作方式读入主Makefile (主Makefile中可以引用其他Makefile)读入被include的其他Makefile初始化文件中的变量推导隐晦规则, 并分析所有规则为所有的目标文件创建依赖关系链根据依赖关系, 决定哪些目标要重新生成执行生成命令 Makefile 初级语法 Makefile 规则 规则语法规则主要有2部分: 依赖关系 和 生成目标的方法. 语法有以下2种: 123target ... : prerequisites ... command ... 或者 123target ... : prerequisites ; command command ... 注 command太长, 可以用 “&quot; 作为换行符 规则中的通配符 :: 表示任意一个或多个字符? :: 表示任意一个字符[…] :: ex. [abcd] 表示a,b,c,d中任意一个字符, [^abcd]表示除a,b,c,d以外的字符, [0-9]表示 0~9中任意一个数字~ :: 表示用户的home目录 路径搜索当一个Makefile中涉及到大量源文件时(这些源文件和Makefile极有可能不在同一个目录中), 这时, 最好将源文件的路径明确在Makefile中, 便于编译时查找. Makefile中有个特殊的变量 VPATH 就是完成这个功能的. 指定了 VPATH 之后, 如果当前目录中没有找到相应文件或依赖的文件, Makefile 回到 VPATH 指定的路径中再去查找.. VPATH 使用方法: vpath &lt;directories&gt; :: 当前目录中找不到文件时, 就从中搜索 vpath &lt;pattern&gt; &lt;directories&gt; :: 符合格式的文件, 就从中搜索 vpath &lt;pattern&gt; :: 清除符合格式的文件搜索路径 vpath :: 清除所有已经设置好的文件路径 复制代码 示例1 - 当前目录中找不到文件时, 按顺序从 src目录 ../parent-dir目录中查找文件1VPATH src:../parent-dir 示例2 - .h结尾的文件都从 ./header 目录中查找1VPATH %.h ./header 示例3 - 清除示例2中设置的规则1VPATH %.h 示例4 - 清除所有VPATH的设置1VPATH Makefile 中的变量 变量定义 ( = or := ) 12OBJS = programA.o programB.oOBJS-ADD = $(OBJS) programC.o 或者 12OBJS := programA.o programB.oOBJS-ADD := $(OBJS) programC.o 其中 = 和 := 的区别在于, := 只能使用前面定义好的变量, = 可以使用后面定义的变量 Makefile内容12OBJS2 = $(OBJS1) programC.oOBJS1 = programA.o programB.o 12all: @echo $(OBJS2) bash中执行 make, 可以看出虽然 OBJS1 是在 OBJS2 之后定义的, 但在 OBJS2中可以提前使用12$ makeprogramA.o programB.o programC.o Makefile内容12OBJS2 := $(OBJS1) programC.oOBJS1 := programA.o programB.o 12all: @echo $(OBJS2) bash中执行 make, 可以看出 OBJS2 中的 $(OBJS1) 为空12$ makeprogramC.o 变量替换Makefile内容 12SRCS := programA.c programB.c programC.cOBJS := $(SRCS:%.c=%.o) 123all: @echo "SRCS: " $(SRCS) @echo "OBJS: " $(OBJS) bash中运行make123$ makeSRCS: programA.c programB.c programC.cOBJS: programA.o programB.o programC.o 变量追加值 += Makefile内容12SRCS := programA.c programB.c programC.cSRCS += programD.c 12all: @echo "SRCS: " $(SRCS) bash中运行make12$ makeSRCS: programA.c programB.c programC.c programD.c 变量覆盖 override作用是使 Makefile中定义的变量能够覆盖 make 命令参数中指定的变量 语法: 123override &lt;variable&gt; = &lt;value&gt;override &lt;variable&gt; := &lt;value&gt;override &lt;variable&gt; += &lt;value&gt; 下面通过一个例子体会 override 的作用： Makefile内容 (没有用override)1234SRCS := programA.c programB.c programC.call: @echo "SRCS: " $(SRCS) bash中运行make12$ make SRCS=nothingSRCS: nothing Makefile内容 (用override)1override SRCS := programA.c programB.c programC.c all: @echo “SRCS: “ $(SRCS) bash中运行make12$ make SRCS=nothingSRCS: programA.c programB.c programC.c 目标变量作用是使变量的作用域仅限于这个目标(target), 而不像之前例子中定义的变量, 对整个Makefile都有效. 语法: 12&lt;target ...&gt; :: &lt;variable-assignment&gt;&lt;target ...&gt; :: override &lt;variable-assignment&gt; (override作用参见 变量覆盖的介绍) Makefile 内容12345678910SRCS := programA.c programB.c programC.ctarget1: TARGET1-SRCS := programD.ctarget1: @echo "SRCS: " $(SRCS) @echo "SRCS: " $(TARGET1-SRCS)target2: @echo "SRCS: " $(SRCS) @echo "SRCS: " $(TARGET1-SRCS) bash中执行make1234567$ make target1SRCS: programA.c programB.c programC.cSRCS: programD.c$ make target2 &lt;-- target2中显示不了 $(TARGET1-SRCS)SRCS: programA.c programB.c programC.cSRCS: Makefile 命令前缀Makefile 中书写shell命令时可以加2种前缀 @ 和 -, 或者不用前缀. 3种格式的shell命令区别如下: 不用前缀 :: 输出执行的命令以及命令执行的结果, 出错的话停止执行前缀 @ :: 只输出命令执行的结果, 出错的话停止执行前缀 - :: 命令执行有错的话, 忽略错误, 继续执行 Makefile 内容 (不用前缀)1234all: echo "没有前缀" cat this_file_not_exist echo "错误之后的命令" &lt;-- 这条命令不会被执行 bash中执行 make$ makeecho “没有前缀” &lt;– 命令本身显示出来没有前缀 &lt;– 命令执行结果显示出来cat this_file_not_existcat: this_file_not_exist: No such file or directorymake: *** [all] Error 1 ########################################################### Makefile 内容 (前缀 @)all: @echo “没有前缀” @cat this_file_not_exist @echo “错误之后的命令” &lt;– 这条命令不会被执行 bash中执行 make$ make没有前缀 &lt;– 只有命令执行的结果, 不显示命令本身cat: this_file_not_exist: No such file or directorymake: *** [all] Error 1 ########################################################### Makefile 内容 (前缀 -)all: -echo “没有前缀” -cat this_file_not_exist -echo “错误之后的命令” &lt;– 这条命令会被执行 bash中执行 make$ makeecho “没有前缀” &lt;– 命令本身显示出来没有前缀 &lt;– 命令执行结果显示出来cat this_file_not_existcat: this_file_not_exist: No such file or directorymake: [all] Error 1 (ignored)echo “错误之后的命令” &lt;– 出错之后的命令也会显示错误之后的命令 &lt;– 出错之后的命令也会执行复制代码 2.4 伪目标伪目标并不是一个”目标(target)”, 不像真正的目标那样会生成一个目标文件. 典型的伪目标是 Makefile 中用来清理编译过程中中间文件的 clean 伪目标, 一般格式如下: .PHONY: clean &lt;– 这句没有也行, 但是最好加上clean: -rm -f *.o 2.5 引用其他的 Makefile语法: include (filename 可以包含通配符和路径) 示例: 复制代码 Makefile 内容all: @echo “主 Makefile begin” @make other-all @echo “主 Makefile end” include ./other/Makefile ./other/Makefile 内容other-all: @echo “other makefile begin” @echo “other makefile end” bash中执行 make$ lltotal 20K-rw-r–r– 1 wangyubin wangyubin 125 Sep 23 16:13 Makefile-rw-r–r– 1 wangyubin wangyubin 11K Sep 23 16:15 makefile.org &lt;– 这个文件不用管drwxr-xr-x 2 wangyubin wangyubin 4.0K Sep 23 16:11 other$ ll other/total 4.0K-rw-r–r– 1 wangyubin wangyubin 71 Sep 23 16:11 Makefile $ make主 Makefile beginmake[1]: Entering directory /path/to/test/makefile&#39; other makefile begin other makefile end make[1]: Leaving directory/path/to/test/makefile’主 Makefile end复制代码 2.6 查看C文件的依赖关系写 Makefile 的时候, 需要确定每个目标的依赖关系. GNU提供一个机制可以查看C代码文件依赖那些文件, 这样我们在写 Makefile 目标的时候就不用打开C源码来看其依赖那些文件了. 比如, 下面命令显示内核源码中 virt/kvm/kvm_main.c 中的依赖关系 $ cd virt/kvm/$ gcc -MM kvm_main.ckvm_main.o: kvm_main.c iodev.h coalesced_mmio.h async_pf.h &lt;– 这句就可以加到 Makefile 中作为编译 kvm_main.o 的依赖关系 2.7 make 退出码Makefile的退出码有以下3种： 0 :: 表示成功执行1 :: 表示make命令出现了错误2 :: 使用了 “-q” 选项, 并且make使得一些目标不需要更新 2.8 指定 Makefile， 指定特定目标默认执行 make 命令时, GNU make在当前目录下依次搜索下面3个文件 “GNUmakefile”, “makefile”, “Makefile”, 找到对应文件之后, 就开始执行此文件中的第一个目标(target). 如果找不到这3个文件就报错. 非默认情况下, 可以在 make 命令中指定特定的 Makefile 和特定的 目标. 示例： 复制代码 Makefile文件名改为 MyMake, 内容target1: @echo “target [1] begin” @echo “target [1] end” target2: @echo “target [2] begin” @echo “target [2] end” bash 中执行 make$ lsMakefile$ mv Makefile MyMake$ lsMyMake$ make &lt;– 找不到默认的 Makefilemake: *** No targets specified and no makefile found. Stop.$ make -f MyMake &lt;– 指定特定的Makefiletarget [1] begintarget [1] end$ make -f MyMake target2 &lt;– 指定特定的目标(target)target [2] begintarget [2] end复制代码 2.9 make 参数介绍make 的参数有很多, 可以通过 make -h 去查看, 下面只介绍几个我认为比较有用的. 参数 含义 –debug[=] 输出make的调试信息, options 可以是 a, b, v-j –jobs 同时运行的命令的个数, 也就是多线程执行 Makefile-r –no-builtin-rules 禁止使用任何隐含规则-R –no-builtin-variabes 禁止使用任何作用于变量上的隐含规则-B –always-make 假设所有目标都有更新, 即强制重编译 2.10 Makefile 隐含规则这里只列一个和编译C相关的. 编译C时，.o 的目标会自动推导为 .c 复制代码 Makefile 中main : main.o gcc -o main main.o #会自动变为:main : main.o gcc -o main main.o main.o: main.c &lt;– main.o 这个目标是隐含生成的 gcc -c main.c复制代码 2.11 隐含规则中的 命令变量 和 命令参数变量2.11.1 命令变量, 书写Makefile可以直接写 shell时用这些变量.下面只列出一些C相关的 变量名 含义 RM rm -fAR arCC ccCXX g++示例: 复制代码 Makefile 内容all: @echo $(RM) @echo $(AR) @echo $(CC) @echo $(CXX) bash 中执行make, 显示各个变量的值$ makerm -farccg++复制代码 2.11.2 命令参数变量变量名 含义 ARFLAGS AR命令的参数CFLAGS C语言编译器的参数CXXFLAGS C++语言编译器的参数 示例: 下面以 CFLAGS 为例演示 复制代码 test.c 内容#include &lt;stdio.h&gt; int main(int argc, char *argv[]){ printf (“Hello Makefile\n”); return 0;} Makefile 内容test: test.o $(CC) -o test test.o bash 中用 make 来测试$ lltotal 24K-rw-r–r– 1 wangyubin wangyubin 69 Sep 23 17:31 Makefile-rw-r–r– 1 wangyubin wangyubin 14K Sep 23 19:51 makefile.org &lt;– 请忽略这个文件-rw-r–r– 1 wangyubin wangyubin 392 Sep 23 17:31 test.c $ makecc -c -o test.o test.ccc -o test test.o &lt;– 这个是自动推导的 $ rm -f test test.o $ make CFLAGS=-Wall &lt;– 命令中加的编译器参数自动追加入下面的编译中了cc -Wall -c -o test.o test.ccc -o test test.o复制代码 2.12 自动变量Makefile 中很多时候通过自动变量来简化书写, 各个自动变量的含义如下: 自动变量 含义 $@ 目标集合$% 当目标是函数库文件时, 表示其中的目标文件名$&lt; 第一个依赖目标. 如果依赖目标是多个, 逐个表示依赖目标$? 比目标新的依赖目标的集合$^ 所有依赖目标的集合, 会去除重复的依赖目标$+ 所有依赖目标的集合, 不会去除重复的依赖目标$* 这个是GNU make特有的, 其它的make不一定支持 Makefile 高级语法 1 嵌套Makefile在 Makefile 初级语法中已经提到过引用其它 Makefile的方法. 这里有另一种写法, 并且可以向引用的其它 Makefile 传递参数. 示例: (不传递参数, 只是调用子文件夹 other 中的Makefile) 复制代码 Makefile 内容all: @echo “主 Makefile begin” @cd ./other &amp;&amp; make @echo “主 Makefile end” ./other/Makefile 内容other-all: @echo “other makefile begin” @echo “other makefile end” bash中执行 make$ lltotal 28K-rw-r–r– 1 wangyubin wangyubin 104 Sep 23 20:43 Makefile-rw-r–r– 1 wangyubin wangyubin 17K Sep 23 20:44 makefile.org &lt;– 这个文件不用管drwxr-xr-x 2 wangyubin wangyubin 4.0K Sep 23 20:42 other$ ll other/total 4.0K-rw-r–r– 1 wangyubin wangyubin 71 Sep 23 16:11 Makefile $ make主 Makefile beginmake[1]: Entering directory /path/to/test/makefile/other&#39; other makefile begin other makefile end make[1]: Leaving directory/path/to/test/makefile/other’主 Makefile end复制代码 示例: (用export传递参数) 复制代码 Makefile 内容export VALUE1 := export.c &lt;– 用了 export, 此变量能够传递到 ./other/Makefile 中VALUE2 := no-export.c &lt;– 此变量不能传递到 ./other/Makefile 中 all: @echo “主 Makefile begin” @cd ./other &amp;&amp; make @echo “主 Makefile end” ./other/Makefile 内容other-all: @echo “other makefile begin” @echo “VALUE1: “ $(VALUE1) @echo “VALUE2: “ $(VALUE2) @echo “other makefile end” bash中执行 make$ make主 Makefile beginmake[1]: Entering directory /path/to/test/makefile/other&#39; other makefile begin VALUE1: export.c &lt;-- VALUE1 传递成功 VALUE2: &lt;-- VALUE2 传递失败 other makefile end make[1]: Leaving directory/path/to/test/makefile/other’主 Makefile end复制代码 补充 export 语法格式如下: export variable = valueexport variable := valueexport variable += value 3.2 定义命令包命令包有点像是个函数, 将连续的相同的命令合成一条, 减少 Makefile 中的代码量, 便于以后维护. 语法: define command…endef 示例: 复制代码 Makefile 内容define run-hello-makefile@echo -n “Hello”@echo “ Makefile!”@echo “这里可以执行多条 Shell 命令!”endef all: $(run-hello-makefile) bash 中运行make$ makeHello Makefile!这里可以执行多条 Shell 命令!复制代码 3.3 条件判断条件判断的关键字主要有 ifeq ifneq ifdef ifndef 语法: 复制代码endif 或者 else endif 复制代码 示例: ifeq的例子, ifneq和ifeq的使用方法类似, 就是取反 复制代码 Makefile 内容all:ifeq (“aa”, “bb”) @echo “equal”else @echo “not equal”endif bash 中执行 make$ makenot equal复制代码 示例: ifdef的例子, ifndef和ifdef的使用方法类似, 就是取反 复制代码 Makefile 内容SRCS := program.c all:ifdef SRCS @echo $(SRCS)else @echo “no SRCS”endif bash 中执行 make$ makeprogram.c复制代码 3.4 Makefile 中的函数Makefile 中自带了一些函数, 利用这些函数可以简化 Makefile 的编写. 函数调用语法如下: $( ) 或者${ } 是函数名 是函数参数 3.4.1 字符串函数字符串替换函数: $(subst ,,) 功能: 把字符串 中的 替换为 返回: 替换过的字符串 复制代码 Makefile 内容all: @echo $(subst t,e,maktfilt) &lt;– 将t替换为e bash 中执行 make$ makemakefile复制代码 模式字符串替换函数: $(patsubst ,,) 功能: 查找中的单词(单词以”空格”, “tab”, “换行”来分割) 是否符合 , 符合的话, 用 替代. 返回: 替换过的字符串 复制代码 Makefile 内容all: @echo $(patsubst %.c,%.o,programA.c programB.c) bash 中执行 make$ makeprogramA.o programB.o复制代码 去空格函数: $(strip ) 功能: 去掉 字符串中开头和结尾的空字符 返回: 被去掉空格的字符串值 复制代码 Makefile 内容VAL := “ aa bb cc “ all: @echo “去除空格前: “ $(VAL) @echo “去除空格后: “ $(strip $(VAL)) bash 中执行 make$ make去除空格前: aa bb cc去除空格后: aa bb cc复制代码 查找字符串函数: $(findstring ,) 功能: 在字符串 中查找 字符串 返回: 如果找到, 返回 字符串, 否则返回空字符串 复制代码 Makefile 内容VAL := “ aa bb cc “ all: @echo $(findstring aa,$(VAL)) @echo $(findstring ab,$(VAL)) bash 中执行 make$ makeaa复制代码 过滤函数: $(filter &lt;pattern…&gt;,) 功能: 以 模式过滤字符串 , 保留 符合模式 的单词, 可以有多个模式 返回: 符合模式 的字符串 复制代码 Makefile 内容all: @echo $(filter %.o %.a,program.c program.o program.a) bash 中执行 make$ makeprogram.o program.a复制代码 反过滤函数: $(filter-out &lt;pattern…&gt;,) 功能: 以 模式过滤字符串 , 去除 符合模式 的单词, 可以有多个模式 返回: 不符合模式 的字符串 复制代码 Makefile 内容all: @echo $(filter-out %.o %.a,program.c program.o program.a) bash 中执行 make$ makeprogram.c复制代码 排序函数: $(sort ) 功能: 给字符串 中的单词排序 (升序) 返回: 排序后的字符串 复制代码 Makefile 内容all: @echo $(sort bac abc acb cab) bash 中执行 make$ makeabc acb bac cab复制代码 取单词函数: $(word ,) 功能: 取字符串 中的 第个单词 (n从1开始) 返回: 中的第个单词, 如果 比 中单词个数要大, 则返回空字符串 复制代码 Makefile 内容all: @echo $(word 1,aa bb cc dd) @echo $(word 5,aa bb cc dd) @echo $(word 4,aa bb cc dd) bash 中执行 make$ makeaa dd复制代码 取单词串函数: $(wordlist ,,) 功能: 从字符串中取从开始到的单词串. 和是一个数字. 返回: 从到的字符串 复制代码 Makefile 内容all: @echo $(wordlist 1,3,aa bb cc dd) @echo $(word 5,6,aa bb cc dd) @echo $(word 2,5,aa bb cc dd) bash 中执行 make$ makeaa bb cc bb复制代码 单词个数统计函数: $(words ) 功能: 统计字符串 中单词的个数 返回: 单词个数 复制代码 Makefile 内容all: @echo $(words aa bb cc dd) @echo $(words aabbccdd) @echo $(words ) bash 中执行 make$ make410复制代码 首单词函数: $(firstword ) 功能: 取字符串 中的第一个单词 返回: 字符串 中的第一个单词 复制代码 Makefile 内容all: @echo $(firstword aa bb cc dd) @echo $(firstword aabbccdd) @echo $(firstword ) bash 中执行 make$ makeaaaabbccdd复制代码 3.4.2 文件名函数取目录函数: $(dir &lt;names…&gt;) 功能: 从文件名序列 中取出目录部分 返回: 文件名序列 中的目录部分 复制代码 Makefile 内容all: @echo $(dir /home/a.c ./bb.c ../c.c d.c) bash 中执行 make$ make/home/ ./ ../ ./复制代码 取文件函数: $(notdir &lt;names…&gt;) 功能: 从文件名序列 中取出非目录部分 返回: 文件名序列 中的非目录部分 复制代码 Makefile 内容all: @echo $(notdir /home/a.c ./bb.c ../c.c d.c) bash 中执行 make$ makea.c bb.c c.c d.c复制代码 取后缀函数: $(suffix &lt;names…&gt;) 功能: 从文件名序列 中取出各个文件名的后缀 返回: 文件名序列 中各个文件名的后缀, 没有后缀则返回空字符串 复制代码 Makefile 内容all: @echo $(suffix /home/a.c ./b.o ../c.a d) bash 中执行 make$ make.c .o .a复制代码 取前缀函数: $(basename &lt;names…&gt;) 功能: 从文件名序列 中取出各个文件名的前缀 返回: 文件名序列 中各个文件名的前缀, 没有前缀则返回空字符串 复制代码 Makefile 内容all: @echo $(basename /home/a.c ./b.o ../c.a /home/.d .e) bash 中执行 make$ make/home/a ./b ../c /home/复制代码 加后缀函数: $(addsuffix ,&lt;names…&gt;) 功能: 把后缀 加到 中的每个单词后面 返回: 加过后缀的文件名序列 复制代码 Makefile 内容all: @echo $(addsuffix .c,/home/a b ./c.o ../d.c) bash 中执行 make$ make/home/a.c b.c ./c.o.c ../d.c.c复制代码 加前缀函数: $(addprefix ,&lt;names…&gt;) 功能: 把前缀 加到 中的每个单词前面 返回: 加过前缀的文件名序列 复制代码 Makefile 内容all: @echo $(addprefix test_,/home/a.c b.c ./d.c) bash 中执行 make$ maketest_/home/a.c test_b.c test_./d.c复制代码 连接函数: $(join ,) 功能: 中对应的单词加到 后面 返回: 连接后的字符串 复制代码 Makefile 内容all: @echo $(join a b c d,1 2 3 4) @echo $(join a b c d,1 2 3 4 5) @echo $(join a b c d e,1 2 3 4) bash 中执行 make$ makea1 b2 c3 d4a1 b2 c3 d4 5a1 b2 c3 d4 e复制代码 3.4.3 foreach语法: $(foreach ,,) 示例: 复制代码 Makefile 内容targets := a b c dobjects := $(foreach i,$(targets),$(i).o) all: @echo $(targets) @echo $(objects) bash 中执行 make$ makea b c da.o b.o c.o d.o复制代码 3.4.4 if这里的if是个函数, 和前面的条件判断不一样, 前面的条件判断属于Makefile的关键字 语法: $(if ,) $(if ,,) 示例: 复制代码 Makefile 内容val := aobjects := $(if $(val),$(val).o,nothing)no-objects := $(if $(no-val),$(val).o,nothing) all: @echo $(objects) @echo $(no-objects) bash 中执行 make$ makea.onothing复制代码 3.4.5 call - 创建新的参数化函数语法: $(call ,,,…) 示例: 复制代码 Makefile 内容log = “====debug====” $(1) “====end====” all: @echo $(call log,”正在 Make”) bash 中执行 make$ make====debug==== 正在 Make ====end====复制代码 3.4.6 origin - 判断变量的来源语法: $(origin ) 返回值有如下类型: 类型 含义 undefined 没有定义过default 是个默认的定义, 比如 CC 变量environment 是个环境变量, 并且 make时没有使用 -e 参数file 定义在Makefile中command line 定义在命令行中override 被 override 重新定义过automatic 是自动化变量 示例: 复制代码 Makefile 内容val-in-file := test-fileoverride val-override := test-override all: @echo $(origin not-define) # not-define 没有定义 @echo $(origin CC) # CC 是Makefile默认定义的变量 @echo $(origin PATH) # PATH 是 bash 环境变量 @echo $(origin val-in-file) # 此Makefile中定义的变量 @echo $(origin val-in-cmd) # 这个变量会加在 make 的参数中 @echo $(origin val-override) # 此Makefile中定义的override变量 @echo $(origin @) # 自动变量, 具体前面的介绍 bash 中执行 make$ make val-in-cmd=val-cmdundefineddefaultenvironmentfilecommand lineoverrideautomatic复制代码 3.4.7 shell语法: $(shell ) 它的作用就是执行一个shell命令, 并将shell命令的结果作为函数的返回. 作用和 &lt;shell command&gt; 一样, ` 是反引号 3.4.8 make 控制函数产生一个致命错误: $(error &lt;text …&gt;) 功能: 输出错误信息, 停止Makefile的运行 复制代码 Makefile 内容all: $(error there is an error!) @echo “这里不会执行!” bash 中执行 make$ makeMakefile:2: *** there is an error!. Stop.复制代码 输出警告: $(warning &lt;text …&gt;) 功能: 输出警告信息, Makefile继续运行 复制代码 Makefile 内容all: $(warning there is an warning!) @echo “这里会执行!” bash 中执行 make$ makeMakefile:2: there is an warning!这里会执行!复制代码 3.5 Makefile中一些GNU约定俗成的伪目标如果有过在Linux上, 从源码安装软件的经历的话, 就会对 make clean, make install 比较熟悉. 像 clean, install 这些伪目标, 广为人知 下面列举一些常用的伪目标, 如果在自己项目的Makefile合理使用这些伪目标的话, 可以让我们自己的Makefile看起来更专业, 呵呵 :) 含义 all 所有目标的目标，其功能一般是编译所有的目标clean 删除所有被make创建的文件install 安装已编译好的程序，其实就是把目标可执行文件拷贝到指定的目录中去print 列出改变过的源文件tar 把源程序打包备份. 也就是一个tar文件dist 创建一个压缩文件, 一般是把tar文件压成Z文件. 或是gz文件TAGS 更新所有的目标, 以备完整地重编译使用check 或 test 一般用来测试makefile的流程]]></content>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LIS]]></title>
    <url>%2F2019%2F09%2F29%2FLIS%2F</url>
    <content type="text"><![CDATA[LIS n^2 dp 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 40005;int a[maxn];int dp[maxn];int main()&#123; int n; scanf("%d",&amp;n); for( int i=0; i&lt;n; i++ )&#123; scanf("%d",a+i); &#125; int ans=0; for( int i=0; i&lt;n; i++ )&#123; dp[i]=1; for( int j=0; j&lt;i; j++ )&#123; if(a[j]&lt;a[i])&#123; dp[i]=max(dp[i],dp[j]+1); &#125; &#125; ans=max(ans,dp[i]); &#125; printf("%d",ans); return 0;&#125; nlogn 二分LIS的nlogn的优化：LIS的优化说白了其实是贪心算法，比如说让你求一个最长上升子序列把，一起走一遍。 比如说（4, 2, 3, 1, 2，3，5）这个序列，求他的最长上升子序列，那么来看，如果求最长的上升序列，那么按照贪心，应该最可能的让该序列的元素整体变小，以便可以加入更多的元素。现在开辟一个新的数组，arr[ 10 ]， { …….} –&gt; 这个是他的空间 ，现在开始模拟贪心算法求解最长上升子序列，第一个数是4，先加进去，那么为{ 4 }再来看下一个数2，它比4小，所以如果他与4替换是不是可以让目前子序列（他这一个元素组成的子序列）变得更小，更方便以后元素的加入呢？是的。所以现在为{ 2 } 再来看他的下一个元素3，他要比2大，所以呢加在他的后面，{ 2, 3}再看下一个元素是1，它比3要小，所以呢为了保证子序列整体尽可能的小（以便可以加入更多的元素），从目前的序列中查找出第一个比他大的数替换掉，那么就变成了{ 1， 3}，继续。。 下一个数是2，那么序列变为{ 1，2}，再下一个数为3，那么序列为{1，2，3}，在下一个数为5，那么序列为{1，2，3，5}，完。 目前序列里又4个元素，所以他的最长子序列的个数为4，但是这个序列是一个伪序列，里面的元素，并不是真正的最长上升子序列，而仅仅和最长上升子序列的个数一样。因为查找的时候用的二分查找，所以时间复杂度为o（nlogn）。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int arr[500],n,dp[500]; scanf("%d",&amp;n); for( int i=1; i&lt;=n; i++ )&#123; scanf("%d",&amp;arr[i]); &#125; int k=1; dp[k]=arr[1]; for( int i=2; i&lt;=n; i++ )&#123; if(arr[i]&gt;dp[k]) dp[++k]=arr[i]; else *lower_bound(dp+1,dp+1+k,arr[i])=arr[i]; &#125; printf("%d\n",k); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方舟编译器编译及其执行]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%96%B9%E8%88%9F%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[华为开发者相关网站 华为鸿蒙系统开发者论坛 华为开发者联盟 方舟编译器 华为 DevEco Studio 华为开源平台 华为云 华为应用市场 方舟编译器编译 环境准备 开发环境推荐您需要安装一个64位版本的Ubuntu（推荐Ubuntu 16.04） 12sudo apt-get -y install openjdk-8-jdk git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip lib32z1-dev qemu g++-multilib gcc-multilib libglib2.0-dev libpixman-1-dev linux-libc-dev:i386sudo apt-get -y install gcc-5-aarch64-linux-gnu g++-5-aarch64-linux-gnu 安装Clang编译器并完成配置（用于编译方舟编译器代码）下载clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04LLVM下载地址：LLVM放置到openarkcompiler/tools目录，打开openarkcompiler/build/config/BUILDCONFIG.gn文件，将GN_C_COMPILER、GN_CXX_COMPILER和GN_AR_COMPILER三个变量配置为Clang编译器所在路径，例如： 123GN_C_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang&quot;GN_CXX_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang++&quot;GN_AR_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/llvm-ar&quot; 其中${MAPLE_ROOT}为openarkcompiler源码根目录。 安装Ninja、GN并完成配置下载Ninja(v1.9.0)及GN(Linux Version)Ninja下载地址：NinjaGN下载地址：gn将GN和Ninja可执行程序放置到openarkcompiler/tools目录，打开openarkcompiler/Makefile文件，将GN和NINJA两个变量配置为GN和Ninja可执行程序所在路径。例如：12GN := $&#123;MAPLE_ROOT&#125;/tools/gn/gnNINJA := $&#123;MAPLE_ROOT&#125;/tools/ninja_1.9.0/ninja 编译器编译 源码下载下载地址：源码可以通过Clone or Download的方式下载openarkcompiler 源码注：默认源码下载目录为openarkcompiler源码编译在openarkcompiler目录下执行以下命令，编译出OpenArkCompiler，默认输出路径 openarkcompiler/out/bin。 12source build/envsetup.shmake 命令说明：source build/envsetup.sh 初始化环境，将OpenArkCompiler工具链路径openarkcompiler/src/bin设置到环境变量中make 编译OpenArkCompiler的Release版本make BUILD_TYPE=DEBUG 编译OpenArkCompiler的Debug版本 编译结果展示 方舟编译器执行过程 在博主跑helloworld的过程中，发现抱错显示少java-core.jar包，在几经周折后在码云上找到了jar包,java-core.jar地址. 在openarkcompiler文件夹下新建文件夹libjava-core，将jar包拷贝至目录下 在openarkcompiler目录下执行 1source build/envsetup.sh cd 至samples文件夹下的helloworld 执行 1make 执行其他samples样例如图所示（在执行过程中找了一个杨辉三角的java代码，跑了一下)]]></content>
      <tags>
        <tag>方舟编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH,公钥,私钥的理解]]></title>
    <url>%2F2019%2F09%2F25%2FSSH-%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先我们需要区分加密和认证这两个基本概念。 加密是将数据资料加密，使得非法用户即使取得加密过的资料，也无法获取正确的资料内容，所以数据加密可以保护数据，防止监听攻击。其重点在于数据的安全性。身份认证是用来判断某个身份的真实性，确认身份后，系统才可以依不同的身份给予不同的权限。其重点在于用户的真实性。两者的侧重点是不同的。 公钥和私钥其次我们还要了解公钥和私钥的概念和作用。 在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是非对称密钥密码系统，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。 公钥私钥的原则：一个公钥对应一个私钥。密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 非对称密钥密码的主要应用就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的，下面我就详细讲解一下两者的区别。 基于公开密钥的加密过程 比如有两个用户Alice和Bob，Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下： Bob将他的公开密钥传送给Alice。 Alice用Bob的公开密钥加密她的消息，然后传送给Bob。 Bob用他的私人密钥解密Alice的消息。 上面的过程可以用下图表示，Alice使用Bob的公钥进行加密，Bob用自己的私钥进行解密。 基于公开密钥的认证过程 身份认证和加密就不同了，主要用户鉴别用户的真伪。这里我们只要能够鉴别一个用户的私钥是正确的，就可以鉴别这个用户的真伪。 还是Alice和Bob这两个用户，Alice想让Bob知道自己是真实的Alice，而不是假冒的，因此Alice只要使用公钥密码学对文件签名发送给Bob，Bob使用Alice的公钥对文件进行解密，如果可以解密成功，则证明Alice的私钥是正确的，因而就完成了对Alice的身份鉴别。整个身份认证的过程如下： Alice用她的私人密钥对文件加密，从而对文件签名。 Alice将签名的文件传送给Bob。 Bob用Alice的公钥解密文件，从而验证签名。 上面的过程可以用下图表示，Alice使用自己的私钥加密，Bob用Alice的公钥进行解密。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地项目恢复]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[今天在从本地仓库推送到github的过程中由于操作不当，导致本地代码被覆盖。瞬间泪崩。一度以为自己写了好几天的代码就断送了。不过一想到git是分布式的，本身就是因为版本控制而开发的呀，所以一定有办法恢复以前版本。方法如下： 查看以往版本号git reflog 找到想要恢复的版本号(黄色)git reset --hard 版本号]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地仓库更新至github]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%9B%B4%E6%96%B0%E8%87%B3github%2F</url>
    <content type="text"><![CDATA[git本地仓库更新至github 右键需要更新的项目 git add .(注意这里有一个空格) git commit -m &quot;更新信息&quot; git remote rm origin &#39;git remote add origin ssh或者HTTPS地址 git push -u origin master/mastercpp 如果推送不成功的话，肯能是本地项目缺少README.md文件，在保证安全的情况下，可以考虑强推 git push -f origin master/mastercpp]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
