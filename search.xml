<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[方舟编译器编译及其执行]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%96%B9%E8%88%9F%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[华为开发者相关网站 华为鸿蒙系统开发者论坛 华为开发者联盟 方舟编译器 华为 DevEco Studio 华为开源平台 华为云 华为应用市场 方舟编译器编译 环境准备 开发环境推荐您需要安装一个64位版本的Ubuntu（推荐Ubuntu 16.04） 12sudo apt-get -y install openjdk-8-jdk git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip lib32z1-dev qemu g++-multilib gcc-multilib libglib2.0-dev libpixman-1-dev linux-libc-dev:i386sudo apt-get -y install gcc-5-aarch64-linux-gnu g++-5-aarch64-linux-gnu 安装Clang编译器并完成配置（用于编译方舟编译器代码）下载clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04LLVM下载地址：LLVM放置到openarkcompiler/tools目录，打开openarkcompiler/build/config/BUILDCONFIG.gn文件，将GN_C_COMPILER、GN_CXX_COMPILER和GN_AR_COMPILER三个变量配置为Clang编译器所在路径，例如： 123GN_C_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang&quot;GN_CXX_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang++&quot;GN_AR_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/llvm-ar&quot; 其中${MAPLE_ROOT}为openarkcompiler源码根目录。 安装Ninja、GN并完成配置下载Ninja(v1.9.0)及GN(Linux Version)Ninja下载地址：NinjaGN下载地址：gn将GN和Ninja可执行程序放置到openarkcompiler/tools目录，打开openarkcompiler/Makefile文件，将GN和NINJA两个变量配置为GN和Ninja可执行程序所在路径。例如：12GN := $&#123;MAPLE_ROOT&#125;/tools/gn/gnNINJA := $&#123;MAPLE_ROOT&#125;/tools/ninja_1.9.0/ninja 编译器编译 源码下载下载地址：源码可以通过Clone or Download的方式下载openarkcompiler 源码注：默认源码下载目录为openarkcompiler源码编译在openarkcompiler目录下执行以下命令，编译出OpenArkCompiler，默认输出路径 openarkcompiler/out/bin。 12source build/envsetup.shmake 命令说明：source build/envsetup.sh 初始化环境，将OpenArkCompiler工具链路径openarkcompiler/src/bin设置到环境变量中make 编译OpenArkCompiler的Release版本make BUILD_TYPE=DEBUG 编译OpenArkCompiler的Debug版本 编译结果展示 方舟编译器执行过程 在博主跑helloworld的过程中，发现抱错显示少java-core.jar包，在几经周折后在码云上找到了jar包,java-core.jar地址. 在openarkcompiler文件夹下新建文件夹libjava-core，将jar包拷贝至目录下 在openarkcompiler目录下执行 1source build/envsetup.sh cd 至samples文件夹下的helloworld 执行 1make 执行其他samples样例如图所示（在执行过程中找了一个杨辉三角的java代码，跑了一下)]]></content>
      <tags>
        <tag>方舟编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH,公钥,私钥的理解]]></title>
    <url>%2F2019%2F09%2F25%2FSSH-%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先我们需要区分加密和认证这两个基本概念。 加密是将数据资料加密，使得非法用户即使取得加密过的资料，也无法获取正确的资料内容，所以数据加密可以保护数据，防止监听攻击。其重点在于数据的安全性。身份认证是用来判断某个身份的真实性，确认身份后，系统才可以依不同的身份给予不同的权限。其重点在于用户的真实性。两者的侧重点是不同的。 公钥和私钥其次我们还要了解公钥和私钥的概念和作用。 在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是非对称密钥密码系统，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。 公钥私钥的原则：一个公钥对应一个私钥。密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 非对称密钥密码的主要应用就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的，下面我就详细讲解一下两者的区别。 基于公开密钥的加密过程 比如有两个用户Alice和Bob，Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下： Bob将他的公开密钥传送给Alice。 Alice用Bob的公开密钥加密她的消息，然后传送给Bob。 Bob用他的私人密钥解密Alice的消息。 上面的过程可以用下图表示，Alice使用Bob的公钥进行加密，Bob用自己的私钥进行解密。 基于公开密钥的认证过程 身份认证和加密就不同了，主要用户鉴别用户的真伪。这里我们只要能够鉴别一个用户的私钥是正确的，就可以鉴别这个用户的真伪。 还是Alice和Bob这两个用户，Alice想让Bob知道自己是真实的Alice，而不是假冒的，因此Alice只要使用公钥密码学对文件签名发送给Bob，Bob使用Alice的公钥对文件进行解密，如果可以解密成功，则证明Alice的私钥是正确的，因而就完成了对Alice的身份鉴别。整个身份认证的过程如下： Alice用她的私人密钥对文件加密，从而对文件签名。 Alice将签名的文件传送给Bob。 Bob用Alice的公钥解密文件，从而验证签名。 上面的过程可以用下图表示，Alice使用自己的私钥加密，Bob用Alice的公钥进行解密。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地项目恢复]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[今天在从本地仓库推送到github的过程中由于操作不当，导致本地代码被覆盖。瞬间泪崩。一度以为自己写了好几天的代码就断送了。不过一想到git是分布式的，本身就是因为版本控制而开发的呀，所以一定有办法恢复以前版本。方法如下： 查看以往版本号git reflog 找到想要恢复的版本号(黄色)git reset --hard 版本号]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地仓库更新至github]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%9B%B4%E6%96%B0%E8%87%B3github%2F</url>
    <content type="text"><![CDATA[git本地仓库更新至github 右键需要更新的项目 git add .(注意这里有一个空格) git commit -m &quot;更新信息&quot; git remote rm origin &#39;git remote add origin ssh或者HTTPS地址 git push -u origin master/mastercpp 如果推送不成功的话，肯能是本地项目缺少README.md文件，在保证安全的情况下，可以考虑强推 git push -f origin master/mastercpp]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
