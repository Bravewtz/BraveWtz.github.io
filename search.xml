<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[02替换空格]]></title>
    <url>%2F2019%2F12%2F30%2F02%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 分析：最简单的方法就是从头到尾遍历，但是时间复杂度为O(n^2)。本文采用一种时间复杂度为O(n)的方法。 我们可以先遍历一次字符串，这样就可以统计出字符串空格的总数，并可以由此计算出替换之后的字符串的总长度。每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\n”），里面有两个空格，因此替换之后字符串的长度是18。 我们从字符串的尾部开始复制和替换。首先准备两个指针，P1和P2，P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。碰到第一个空格之后，把P1向前移动1格，在P2之前插入字符串”%20”。由于”%20”的长度为3，同时也要把P2向前移动3格。 1234567891011121314151617181920class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int numSpace=0; int i=0; while(str[i]!='\0')&#123; if(str[i]==' ')numSpace++; i++; &#125; int newLen=length+2*numSpace; for(int j=length;j&gt;=0&amp;&amp;newLen&gt;=0;j--)&#123; if(str[j]==' ')&#123; str[newLen--]='0'; str[newLen--]='2'; str[newLen--]='%'; &#125; else str[newLen]=str[j]; &#125; &#125;&#125;; 123456# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here return s.replace(' ','%20')]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01二维数组中的查找]]></title>
    <url>%2F2019%2F12%2F29%2F01%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 分析：首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。 如果在一个二维数组中找到数字7，则返回true，如果没有找到，则返回false。 1234567891011121314151617class solution&#123;public: bool Find(int target,vector&lt;vector&lt;int&gt; &gt;array)&#123; int rows=array.size(); int cols=array[0].size(); if(!array.empty()&amp;&amp;rows&gt;0&amp;&amp;cols&gt;0)&#123; int row=0; int col=cols-1; while(row&lt;=rows-1&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) return true; else if(array[row][col]&gt;target) col--; else row++; &#125; &#125; return false; &#125;&#125;;]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用urllib.urlopen向有道翻译发送数据获取翻译结果]]></title>
    <url>%2F2019%2F12%2F29%2F%E5%88%A9%E7%94%A8urllib-urlopen%E5%90%91%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E7%BF%BB%E8%AF%91%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[urlopen的data参数 我们可以使用data参数，向服务器发送数据。根据HTTP规范，GET用于信息获取，POST是向服务器提交数据的一种请求，再换句话说： 从客户端向服务器提交数据使用POST； 从服务器获得数据到客户端使用GET(GET也可以提交，暂不考虑)。 如果没有设置urlopen()函数的data参数，HTTP请求采用GET方式，也就是我们从服务器获取信息，如果我们设置data参数，HTTP请求采用POST方式，也就是我们向服务器传递数据。 data参数有自己的格式，它是一个基于application/x-www.form-urlencoded的格式，具体格式我们不用了解， 因为我们可以使用urllib.parse.urlencode()函数将字符串自动转换成上面所说的格式。 发送data实例 记住这些信息，这是我们一会儿写程序需要用到的。 1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-from urllib import requestfrom urllib import parseimport jsonif __name__ == "__main__": #对应上图的Request URL Request_URL = 'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;smartresult=ugc&amp;sessionFrom=https://www.baidu.com/link' #创建Form_Data字典，存储上图的Form Data Form_Data = &#123;&#125; Form_Data['type'] = 'AUTO' Form_Data['i'] = 'brave' Form_Data['doctype'] = 'json' Form_Data['Version'] = '2.1' Form_Data['keyfrom'] = 'fanyi.web' Form_Data['ue'] = 'ue:UTF-8' Form_Data['action'] = 'FY_BY_CLICKBUTTON' #使用urlencode方法转换标准格式 data = parse.urlencode(Form_Data).encode('utf-8') #传递Request对象和转换完格式的数据 response = request.urlopen(Request_URL,data) #读取信息并解码 html = response.read().decode('utf-8') #使用JSON translate_results = json.loads(html) #找到翻译结果 translate_results = translate_results['translateResult'][0][0]['tgt'] #打印翻译信息 print("翻译的结果是：%s" % translate_results)]]></content>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell模拟考勤程序]]></title>
    <url>%2F2019%2F11%2F03%2FShell%E6%A8%A1%E6%8B%9F%E8%80%83%E5%8B%A4%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[shell语法 任务：设计一个考勤模拟程序，实现如下功能选择界面，要求使用函数 1. 上班签到 2. 下班签出 3. 缺勤信息查阅 4. 退出 考勤程序运行后，提示用户输入上述功能选择，并验证用户输入的用户名和密码；用户信息保存在userinfo.dat中。 如果是上班签到，记录签到信息，如果签到时间大于上午8时，则提示用户迟到，并记录该迟到信息到check.dat。 如果是下班签出，记录签出信息，如果签出时间小于下午6时，则提示用户早退，并记录该早退信息到check.dat。 如果用户选择缺勤信息查询，则将check.dat中对应该用户的迟到早退信息查出并显示。 用户选择功能执行完，shell程序继续回到功能选择界面等待下一个用户进行操作。 实验环境 基于linux的deepin系统（优点：界面也太好看了吧 缺点：生态没有ubuntu Centos Arch完善） 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#!/usr/bin/env bash# 考勤模拟程序#作者：Bravewtz#date 2019/11/01function main()&#123; echo "----------Bravewtz提醒您-------------------------" echo " 欢迎使用考勤程序！ " echo "------------------------------------------------" createInfoFile; read -p "请输入您的账号： " username read -p "请输入您的密码： " passwordisLogin $username $password; while [[ 1 == 1 ]]; do menu; read -p "请输入您的选择：" choice case $choice in 1 ) signIn $username; ;; 2 ) logOff $username; ;; 3 ) absenceConsult $username; ;; 4 ) exit1; ;; * ) echo -e "请选择功能 1 or 2 or 3 or 4！\n" ;; esac done&#125;#菜单function menu()&#123; echo "------------------------------------------------------------" echo " 1.上班签到 " echo " 2.下班签出 " echo " 3.缺勤信息查阅 " echo " 4.退出 " echo "------------------------------------------------------------"&#125;#检查账号密码function isLogin()&#123; while read line do if [[ "$line" == "$1:$2" ]]; then return 0 fi done &lt; userinfo.dat #从文件读入 echo "用户名或密码错误，请重新输入哦" read -p "请输入您的账号： " username read -p "请输入您的密码： " passwordisLogin $username $password;&#125;#上班签到function signIn()&#123; hour=`date +%H` if [[ $hour -gt 8 ]]; then echo "你上班迟到了呀！已经将迟到信息记录在check.dat中。" echo "$1 上班迟到————日期：`date`" &gt;&gt; check.dat else echo "上班签到成功！" fi main;&#125;#下班迁出function logOff()&#123; echo "下班签出成功！" hour=`date +%H` if [[ $hour -lt 18 ]]; then echo "你现在属于早退哦！已经将早退信息记录在check.dat中。" echo "$1 下班早退————日期：`date`" &gt;&gt; check.dat fi main;&#125;#缺勤查阅function absenceConsult()&#123; cat check.dat|grep -n "$1"&#125;#退出程序function exit1()&#123; exit 0&#125;s#创建配置文件ssfunction createInfoFile()&#123; if [[ ! -e userinfo.dat ]]; then touch userinfo.dat #保存用户名和密码 chmod 777 userinfo.dat fi if [[ ! -e check.dat ]]; then touch check.dat #保存迟到早退信息 chmod 777 check.dat fi&#125;#执行main函数main 实验结果]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCv透视变换原理及实现]]></title>
    <url>%2F2019%2F10%2F31%2FOpenCv%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[OpenCV提供了两种图片变换的方式：仿射变换和透视变换，两者的区别很容易区分 前者是将矩形的图片变成平行四边形 后者是将图片变成梯形 这两种变换虽然都有各自的应用场景，但在实际的图片变换中由于透视效应的存在，后者的使用更加普遍，本文为大家详解OpenCV透视变换的透视变换原理及实例展示。简介透视变换(Perspective Transformation)是将成像投影到一个新的视平面(Viewing Plane)，也称作投影映射(Projective Mapping)。如图所示 函数原型OpenCV提供了warpPerspective( )函数来实现图片的透视变换，只需要输入梯形四个顶点的坐标和目标画布四个角的坐标，即可自动完成转换。核心代码只有两行：首先读取两个坐标数组，计算变换矩阵；然后根据变换矩阵对原图进行透视变换，并输出到目标画布。 cv2.getPerspectiveTransform(src, dst) → retval 参数说明 src：源图像中待测矩形的四点坐标 sdt：目标图像中矩形的四点坐标原图像的四个坐标顺序应与目标图像中的四个坐标一 一随影，若都是顺时针则都是顺时针，若都是 Z 字型，则都是 Z 字型。返回由源图像中矩形到目标图像矩形变换的矩阵，得到矩阵得有用才行啊，所以引出下面这个函数 cv2.warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) → dst参数为： src：输入图像M：变换矩阵dsize：目标图像shapeflags：插值方式，interpolation方法INTER_LINEAR或INTER_NEARESTborderMode：边界补偿方式，BORDER_CONSTANT or BORDER_REPLICATEborderValue：边界补偿大小，常值，默认为0或者 cv2.perspectiveTransform(src, m[, dst]) → dst 参数解释 src：输入的2通道或者3通道的图片 m：变换矩阵实例1 图片矫正我们在给报纸、杂志、身份证、银行卡等矩形目标拍照时，受相机角度和高度的影响往往会拍出梯形的照片（如下图），这样的照片不仅不够美观而且给文字识别带来较大难度，将梯形的图片转换成标准的矩形就要对图片进行透视变换。原始图像效果如下：转换后的效果如下图所示，效果还是很让人满意的。实例 2 头像替换广告牌在实际应用中我们不仅需要将梯形矫正为矩形，有时还需要将矩形转换成梯形，warpPerspective( )当然也能胜任，下面我们再用一个例子来演示。实际效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[双线型插值法及其py缩放实现]]></title>
    <url>%2F2019%2F10%2F22%2F%E5%8F%8C%E7%BA%BF%E5%9E%8B%E6%8F%92%E5%80%BC%E6%B3%95%E5%8F%8A%E5%85%B6py%E7%BC%A9%E6%94%BE%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[双线性插值假设源图像大小为mxn，目标图像为axb。那么两幅图像的边长比分别为：m/a和n/b。注意，通常这个比例不是整数，编程存储的时候要用浮点型。目标图像的第（i,j）个像素点（i行j列）可以通过边长比对应回源图像。其对应坐标为（im/a,jn/b）。显然，这个对应坐标一般来说不是整数，而非整数的坐标是无法在图像这种离散数据上使用的。双线性插值通过寻找距离这个对应坐标最近的四个像素点，来计算该点的值（灰度值或者RGB值）。 若图像为灰度图像，那么（i，j）点的灰度值的数学计算模型是 f(x,y)=b1+b2x+b3y+b4xy 如图，已知Q12，Q22，Q11，Q21，但是要插值的点为P点，这就要用双线性插值了，首先在x轴方向上，对R1和R2两个点进行插值，这个很简单，然后根据R1和R2对P点进行插值，这就是所谓的双线性插值。在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。 假如我们想得到未知函数 f 在点 P = (x, y) 的值，假设我们已知函数 f 在 Q11 = (x1, y1)、Q12 = (x1, y2), Q21 = (x2, y1) 以及 Q22 = (x2, y2) 四个点的值。首先在 x 方向进行线性插值，得到然后在 y 方向进行线性插值，得到这样就得到所要的结果 f(x, y)，如果选择一个坐标系统使得 的四个已知点坐标分别为 (0, 0)、(0, 1)、(1, 0) 和 (1, 1)，那么插值公式就可以化简为或者用矩阵运算表示为这种插值方法的结果通常不是线性的，线性插值的结果与插值的顺序无关。首先进行 y 方向的插值，然后进行 x 方向的插值，所得到的结果是一样的。 python代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445 #--*-- encoding: utf-8 --*--'''Date: 2019.10.22Content: python3 实现双线性插值图像缩放算法'''import numpy as npimport cv2import mathdef bi_linear(src, dst, target_size): pic = cv2.imread(src) # 读取输入图像 th, tw = target_size[0], target_size[1] emptyImage = np.zeros(target_size, np.uint8) for k in range(3): for i in range(th): for j in range(tw): # 首先找到在原图中对应的点的(X, Y)坐标 corr_x = (i+0.5)/th*pic.shape[0]-0.5 corr_y = (j+0.5)/tw*pic.shape[1]-0.5 # if i*pic.shape[0]%th==0 and j*pic.shape[1]%tw==0: # 对应的点正好是一个像素点，直接拷贝 # emptyImage[i, j, k] = pic[int(corr_x), int(corr_y), k] point1 = (math.floor(corr_x), math.floor(corr_y)) # 左上角的点 point2 = (point1[0], point1[1]+1) point3 = (point1[0]+1, point1[1]) point4 = (point1[0]+1, point1[1]+1) fr1 = (point2[1]-corr_y)*pic[point1[0], point1[1], k] + (corr_y-point1[1])*pic[point2[0], point2[1], k] fr2 = (point2[1]-corr_y)*pic[point3[0], point3[1], k] + (corr_y-point1[1])*pic[point4[0], point4[1], k] emptyImage[i, j, k] = (point3[0]-corr_x)*fr1 + (corr_x-point1[0])*fr2 cv2.imwrite(dst, emptyImage) # 用 CV2 resize函数得到的缩放图像 new_img = cv2.resize(pic, (200, 300)) cv2.imwrite('pic/1_cv_img.png', new_img)def main(): src = './sucai1.jpg' dst = './sucai1_linear.png' target_size = (300, 200, 3) # 变换后的图像大小 bi_linear(src, dst, target_size)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>双线性插值法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PAT】甲级-1053 Path of Equal Weight]]></title>
    <url>%2F2019%2F10%2F18%2F%E3%80%90PAT%E3%80%91%E7%94%B2%E7%BA%A7-1053-Path-of-Equal-Weight%2F</url>
    <content type="text"><![CDATA[题目链接 Given a non-empty tree with root R, and with weight W​i​​assigned to each tree node T​i​​. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure. Input Specification: 123456789Each input file contains one test case. Each case starts with a line containing 0&lt;N≤100, the number of nodes in a tree, M (&lt;N), the number of non-leaf nodes, and 0&lt;S&lt;2​30​​, the given weight number. The next line contains N positive numbers where W​i​​(&lt;1000) corresponds to the tree node T​i​​. Then M lines follow, each in the format:ID K ID[1] ID[2] ... ID[K]where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID's of its children. For the sake of simplicity, let us fix the root ID to be 00. Output Specification: 1For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line. AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5+10;#define LL long long#define INF 0x3f3f3f3fstruct NODE&#123; int w; vector&lt;int&gt; child;&#125;;vector&lt;NODE&gt; V;vector&lt;int&gt; path;int ans;void dfs(int index,int nodeNum,int sum)&#123; if(sum&gt;ans) return ; if(sum==ans)&#123; if(V[index].child.size()!=0) return ; for(int i=0;i&lt;nodeNum;i++)&#123; printf("%d%c",V[path[i]].w,i!=nodeNum-1?' ':'\n'); &#125; return ; &#125; for(int i=0;i&lt;V[index].child.size();i++)&#123; int node=V[index].child[i]; path[nodeNum]=node; dfs(node,nodeNum+1,sum+V[node].w); &#125;&#125;int cmp(int a,int b)&#123; return V[a].w&gt;V[b].w; &#125;int main()&#123; int n,m,node,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;ans); V.resize(n); path.resize(n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;V[i].w); for(int i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;node,&amp;k); V[node].child.resize(k); for(int j=0;j&lt;k;j++)&#123; scanf("%d",&amp;V[node].child[j]); &#125; sort(V[node].child.begin(),V[node].child.end(),cmp); &#125; dfs(0,1,V[0].w); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PAT】甲级-Set Similarity (STL)]]></title>
    <url>%2F2019%2F10%2F15%2F%E3%80%90PAT%E3%80%91%E7%94%B2%E7%BA%A7-Set-Similarity-STL%2F</url>
    <content type="text"><![CDATA[题目链接 Given two sets of integers, the similarity of the sets is defined to be Nc​​/N​t​​×100%, where Nc​​is the number of distinct common numbers shared by the two sets, and Nt ​​is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets. Input Specification: 12345Each input file contains one test case. Each case first gives a positive integer N (≤50) which is the total number of sets. Then N lines follow, each gives a set with a positive M (≤10​4​​) and followed by M integers in the range [0,10​9​​]. After the input of sets, a positive integer K (≤2000) is given, followed by K lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to N). All the numbers in a line are separated by a space. Output Specification: 1For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place. AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5+10;#define LL long long#define INF 0x3f3f3f3fint n,m,k,tmp,a,b;int main()&#123; scanf("%d",&amp;n); vector&lt;set&lt;int&gt; &gt;V(n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;m); set&lt;int&gt; S; for(int j=0;j&lt;m;j++)&#123; scanf("%d",&amp;tmp); S.insert(tmp); &#125; V[i]=S; &#125; scanf("%d",&amp;k); for(int i=0;i&lt;k;i++)&#123; scanf("%d%d",&amp;a,&amp;b); int nc=0,nt=V[b-1].size(); for(auto it=V[a-1].begin();it!=V[a-1].end();it++)&#123; if(V[b-1].find(*it)==V[b-1].end())&#123; nt++; &#125; else nc++; &#125; double ans=(double)nc/nt*100; printf("%.1f%%\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PAT】甲级-1049 Counting Ones数学]]></title>
    <url>%2F2019%2F10%2F14%2F%E3%80%90PAT%E3%80%91%E7%94%B2%E7%BA%A7-1049-Counting-Ones%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[题目链接 The task is simple: given any positive integer N, you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to N. For example, given N being 12, there are five 1’s in 1, 10, 11, and 12. Input Specification: 123Each input file contains one test case which gives the positive N (≤2​30​​ ). Output Specification: 1For each test case, print the number of 1's in one line. 分析 从第一位到最高位，设now为当前位的数字，left为now左边的所有数字构成的数字，right为now右边所有构成的数字。只需要一次次累加对于当前位now来说可能出现1的个数，然后把他们累加即可。 对于now==0,那么ans+=left*a; //因为now==0说明now位只有在left从0~left-11的时候会产⽣1，所以会产 ⽣left次，但是⼜因为右边会重复从0~999…出现a次其他同理 AC代码 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5+10;#define LL long long#define INF 0x3f3f3f3fint main()&#123; int n,left=0,right=0,a=1,pos,now,ans; scanf("%d",&amp;n); while(n/a)&#123; left=n/(a*10),now=n/a%10,right=n%a; if(now==0) ans+=left*a; else if(now==1) ans+=left*a+right+1; else ans+=(left+1)*a; a*=10; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PAT】甲级 1072 Gas Station 最短路]]></title>
    <url>%2F2019%2F10%2F10%2F%E3%80%90PAT%E3%80%91%E7%94%B2%E7%BA%A7-1072-Gas-Station-%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[题目链接 A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range.Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number. Input Each input file contains one test case. For each case, the first line contains 4 positive integers: N (≤10^3​​), the total number of houses; M (≤10), the total number of the candidate locations for the gas stations; K (≤10^4​​), the number of roads connecting the houses and the gas stations; and D​S​​, the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N, and all the candidate locations are numbered from G1 to GM.Then K lines follow, each describes a road in the formatP1 P2 Distwhere P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road. Output For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution. Input Sample 1234567891011124 3 11 51 2 21 4 21 G1 41 G2 32 3 22 G2 13 4 23 G3 24 G1 3G2 G1 1G3 G2 2 Output Sample 12G12.0 3.3 分析：加油站的输入是字符串形式，可以写个函数处理一下G1=n+1G2=n+2n为居民点个数然后对每一个加油站使用一次spfa求出到所有点的最短路，对得出来的路径分析一下即可出答案 AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2000;#define LL long long#define INF 0x3f3f3f3fstruct edge&#123; int to,w;&#125;;vector&lt;edge&gt; G[maxn];//int G[maxn][maxn]=&#123;0&#125;;typedef pair&lt;int,int&gt; P;int d[maxn];int vis[maxn];int n,m,k,ds;int getnum(string s)&#123; int ans=0; if(s[0]=='G')&#123; for(int i=1;i&lt;s.length();i++)&#123; ans=ans*10+s[i]-'0'; &#125; ans+=n; &#125; else&#123; for(int i=0;i&lt;s.length();i++)&#123; ans=ans*10+s[i]-'0'; &#125; &#125; return ans;&#125;void dijkstra(int s)&#123; priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;pq; memset(d,INF,sizeof(d)); memset(vis,0,sizeof(vis)); d[s]=0; pq.push(P&#123;0,s&#125;); while(!pq.empty())&#123; P p=pq.top(); pq.pop(); int u=p.second; if(vis[u]) continue; vis[u]=1; for(int i=0;i&lt;G[u].size();i++)&#123; edge e=G[u][i]; if(!vis[e.to]&amp;&amp;d[e.to]&gt;d[u]+e.w)&#123; d[e.to]=d[u]+e.w; pq.push(P&#123;d[e.to],e.to&#125;); &#125; &#125;// for(int v=1;v&lt;=n+m;v++)&#123;// if(!vis[v]&amp;&amp;G[u][v]&amp;&amp;d[v]&gt;d[u]+G[u][v])&#123;// d[v]=d[u]+G[u][v];// pq.push(P&#123;d[v],v&#125;);// &#125;// &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;ds); for(int i=0;i&lt;k;i++)&#123; string s1,s2; int dis; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;dis; int u=getnum(s1); int v=getnum(s2);// G[u][v]=G[v][u]=dis; G[u].push_back(edge&#123;v,dis&#125;); G[v].push_back(edge&#123;u,dis&#125;); &#125; double ansdis=0,ansavg=INF; int ansid; for(int s=n+1;s&lt;=n+m;s++)&#123;// memset(vis,0,sizeof(vis)); dijkstra(s); double mindis=INF,avg=0; for(int i=1;i&lt;=n;i++)&#123; if(d[i]&gt;ds)&#123; mindis=-1; break; &#125; if(d[i]&lt;mindis) mindis=d[i]; avg+=d[i]*1.0/n; &#125; if(mindis==-1) continue; if(mindis&gt;ansdis)&#123;//最近的村庄距离最大 ansdis=mindis; ansavg=avg; ansid=s; &#125; else if(mindis==ansdis&amp;&amp;avg&lt;ansavg)&#123; ansavg=avg; ansid=s; &#125; &#125; if(ansavg==INF) printf("No Solution"); else&#123; printf("G%d\n",ansid-n); printf("%.1f %.1f",ansdis,ansavg); &#125; return 0;&#125;/*4 3 11 51 2 21 4 21 G1 41 G2 32 3 22 G2 13 4 23 G3 24 G1 3G2 G1 1G3 G2 2*/]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ - 2785】4 Values whose Sum is 0(折半枚举|双向搜索)]]></title>
    <url>%2F2019%2F10%2F08%2F%E3%80%90POJ-2785%E3%80%914-Values-whose-Sum-is-0-%E6%8A%98%E5%8D%8A%E6%9E%9A%E4%B8%BE-%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[题目链接 https://vjudge.net/problem/POJ-2785 The SUM problem can be formulated as follows: given four lists A, B, C, D of integer values, compute how many quadruplet (a, b, c, d ) ∈ A x B x C x D are such that a + b + c + d = 0 . In the following, we assume that all lists have the same size n . InputThe first line of the input file contains the size of the lists n (this value can be as large as 4000). We then have n lines containing four integer values (with absolute value as large as 2 28 ) that belong respectively to A, B, C and D . OutputFor each input file, your program has to write the number quadruplets whose sum is zero. Sample Input 12345676-45 22 42 -16-41 -27 56 30-36 53 -37 77-36 30 -75 -4626 -38 -10 62-32 -54 -6 45 Sample Output 15 分析：先从CD两个数组中枚举n^2种组合，将其和排好序，然后对AB数组进行二分搜索，复杂度 O(n^2logn) AC代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 4010;#define LL long long#define INF 0x3f3f3f3fint A[maxn],B[maxn],C[maxn],D[maxn];int CD[maxn];int n;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d%d%d",&amp;A[i],&amp;B[i],&amp;C[i],&amp;D[i]); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; CD[i*n+j]=C[i]+D[j]; &#125; sort(CD,CD+n*n); LL ans=0; int sum=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; ans=-(A[i]+B[j]); int cnt=upper_bound(CD,CD+n*n,ans)-lower_bound(CD,CD+n*n,ans); sum+=cnt; &#125; printf("%d\n",sum); return 0;&#125;/*6-45 22 42 -16-41 -27 56 30-36 53 -37 77-36 30 -75 -4626 -38 -10 62-32 -54 -6 45*/]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ - 3723】Conscription（Kruskal变形)]]></title>
    <url>%2F2019%2F10%2F06%2F%E3%80%90POJ-3723%E3%80%91Conscription%EF%BC%88Kruskal%E5%8F%98%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目链接 https://vjudge.net/problem/POJ-3723 Windy has a country, and he wants to build an army to protect his country. He has picked up N girls and M boys and wants to collect them to be his soldiers. To collect a soldier without any privilege, he must pay 10000 RMB. There are some relationships between girls and boys and Windy can use these relationships to reduce his cost. If girl x and boy y have a relationship d and one of them has been collected, Windy can collect the other one with 10000-d RMB. Now given all the relationships between girls and boys, your assignment is to find the least amount of money Windy has to pay. Notice that only one relationship can be used when collecting one soldier. InputThe first line of input is the number of test case.The first line of each test case contains three integers, N, M and R.Then R lines followed, each contains three integers xi, yi and di.There is a blank line before each test case.1 ≤ N, M ≤ 100000 ≤ R ≤ 50,0000 ≤ xi &lt; N0 ≤ yi &lt; M0 &lt; di &lt; 10000 OutputFor each test case output the answer in a single line. Input 123456789101112131415161718192021222325 5 84 3 68311 3 45830 0 65920 1 30633 3 49751 3 20494 2 21042 2 7815 5 102 4 98203 2 62363 1 88642 4 83262 0 51562 0 14634 1 24390 4 43733 4 88892 4 3133 Output 127107154223 分析由于题目男女都是0开始编号，所以我们首先应该对男女进行重新编号，我处理的方法是将女的编号在男的后。然后对于每个关系，我们建立对应一条边，然后求出最小生成树，最后再算出多少人没有被招到即。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 5e4+10;#define LL long long#define INF 0x3f3f3f3fstruct edge&#123; int u,v,w; bool operator&lt;(const edge &amp;x)const&#123; return w&lt;x.w; &#125;&#125;edge[maxn];int n,m,r,pre[maxn];void upset()&#123; for(int i=0;i&lt;n+m;i++) pre[i]=i;&#125;int Find(int x)&#123; int r=x; while(r!=pre[r])&#123; r=pre[r]; &#125; int i=x,j; while(pre[i]!=r)&#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;void mix(int u,int v)&#123; int fu=Find(u); int fv=Find(v); if(fu!=fv) pre[fu]=fv;&#125;int Kruskal()&#123; upset(); int sum=0; int cnt=0; for(int i=0;i&lt;r;i++)&#123; int u=edge[i].u; int v=edge[i].v; if(Find(u)!=Find(v))&#123; sum+=edge[i].w; mix(u,v); cnt++; &#125; if(cnt&gt;=n+m-1) break; &#125; return sum+(n+m-cnt)*10000;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;r); for(int i=0;i&lt;r;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); edge[i].u=u;edge[i].v=n+v; edge[i].w=10000-w; &#125; sort(edge,edge+r); printf("%d\n",Kruskal()); &#125; return 0;&#125;/*25 5 84 3 68311 3 45830 0 65920 1 30633 3 49751 3 20494 2 21042 2 7815 5 102 4 98203 2 62363 1 88642 4 83262 0 51562 0 14634 1 24390 4 43733 4 88892 4 3133*/]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ - 3255】Roadblocks（次短路 Dijkstra算法）]]></title>
    <url>%2F2019%2F10%2F06%2F%E3%80%90POJ-3255%E3%80%91Roadblocks%EF%BC%88%E6%AC%A1%E7%9F%AD%E8%B7%AF-Dijkstra%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Bessie has moved to a small farm and sometimes enjoys returning to visit one of her best friends. She does not want to get to her old home too quickly, because she likes the scenery along the way. She has decided to take the second-shortest rather than the shortest path. She knows there must be some second-shortest path.The countryside consists of R (1 ≤ R ≤ 100,000) bidirectional roads, each linking two of the N (1 ≤ N ≤ 5000) intersections, conveniently numbered 1..N. Bessie starts at intersection 1, and her friend (the destination) is at intersection N.The second-shortest path may share roads with any of the shortest paths, and it may backtrack i.e., use the same road or intersection more than once. The second-shortest path is the shortest path whose length is longer than the shortest path(s) (i.e., if two or more shortest paths exist, the second-shortest path is the one whose length is longer than those but no longer than any other path). Input 123454 41 2 1002 4 2002 3 2503 4 100 Output 1450 分析：求从s到t的次短路径有两种情况： 起点s到某个顶点u的最短路+d(u,t)。 起点到某个顶点u的次短路+d(u,t)。所以更新路径的时候需要把最短路径和次短路径两个都记录下来。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 5000+10;#define LL long long#define INF 0x3f3f3f3ftypedef struct edge&#123; int to,cost; edge(int to,int cost):to(to),cost(cost)&#123;&#125;&#125;edge;typedef pair&lt;int,int&gt; P;vector&lt;edge&gt; G[maxn];int N,R;int dist[maxn];//最短路int dist2[maxn];//次短路priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;pq;int main()&#123; scanf("%d%d",&amp;N,&amp;R); for(int i=0;i&lt;R;i++)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); G[a].push_back(edge&#123;b,c&#125;); G[b].push_back(edge&#123;a,c&#125;); &#125; fill(dist+1,dist+N+1,INF); fill(dist2+1,dist2+N+1,INF); dist[1]=0; pq.push(P&#123;0,1&#125;); while(!pq.empty())&#123; P p=pq.top(); pq.pop(); int u=p.second; if(dist2[u]&lt;p.first) continue;//此路径大于次短路，那么一定大于最短路。剪枝 int d=p.first; for(int i=0;i&lt;G[u].size();i++)&#123; edge e=G[u][i]; int d2=d+e.cost; if(dist[e.to]&gt;d2)&#123;// dist[e.to]=d2; swap(dist[e.to],d2); pq.push(P&#123;dist[e.to],e.to&#125;); &#125; if(dist2[e.to]&gt;d2&amp;&amp;dist[e.to]&lt;d2)&#123; dist2[e.to]=d2; pq.push(P&#123;dist2[e.to],e.to&#125;); &#125; &#125; &#125;// for(int i=1;i&lt;=N;i++)&#123;// printf("%d ",dist[i]);// &#125;// cout&lt;&lt;endl;// for(int i=1;i&lt;=N;i++)&#123;// printf("%d ",dist2[i]);// &#125;// cout&lt;&lt;endl; printf("%d\n",dist2[N]); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路&最小生成树板子整理]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%9D%BF%E5%AD%90%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[dijkstra板子123456789101112131415161718192021222324252627282930313233343536373839优先队列优化：#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std;#define LL long long#define INF 0x3f3f3f3fconst int maxn = 1e5+10;struct edge&#123; int to,cost;&#125;;vector&lt;edge&gt; G[maxn];typedef pair&lt;int,int&gt; P;//first是最短距离，second是顶点编号int d[maxn];int v;void dijkstra(int s)&#123; priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; pq; fill(d,d+v,INF); d[s]=0; pq.push(P&#123;0,s&#125;); while(pq.empty())&#123; P p=pq.top(); pq.pop(); int u=p.second; if(d[u]&lt;p.first) continue; for(int i=0;i&lt;G[u].size();i++)&#123; edge e=G[u][i]; if(d[e.to]&gt;d[u]+e.cost)&#123; d[e.to]=d[u]+e.cost; pq.push(P&#123;d[e.to,e.to&#125;); &#125; &#125; &#125;&#125; Floyed板子123456789101112131415161718192021222324252627typedef struct&#123; char vertex[VertexNum];//顶点表 int edges[VertexNum][VertexNum];//邻接矩阵，可看作边表 int n,e;//图中当前顶点数和边表&#125;MGraph;void Floyed(Mgraph g)&#123; int A[MAXV][MAXV]; int path[MAXV][AMXV]; int i,j,k,n=g.n; for( i=0; i&lt;n; i++ )&#123; for( j=0; j&lt;n; j++ )&#123; A[i][j]=g.edges[i][j]; path[i][j]=-1; &#125; &#125; for(k=0; k&lt;n; k++ )&#123; for(i=0; i&lt;n; i++ )&#123; for( j=0; j&lt;n; j++ )&#123; if(A[i][j]&gt;(A[i][k]+A[k][j]))&#123; A[i][j]=A[i][k]+A[k][j]; path[i][j]=k; &#125; &#125; &#125; &#125;&#125; Prime板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e5+10;#define LL long long#define INF 0x3f3f3f3fint n;int G[maxn][maxn];int dist[maxn];bool vis[maxn];int prim(int cur)&#123;//首个挑选到的结点 int index=cur; int sum=0;//最短路径之和 memset(vis,false,sizeof(vis)); vis[cur]=true; for(int i=0;i&lt;n;i++)&#123; dist[i]=G[cur][i]; &#125; for(int i=1;i&lt;n;i++)&#123; int minn=INF; for(int j=0;j&lt;n;j++)&#123; if(!vis[j]&amp;&amp;dist[j]&lt;minn)&#123; minn=dist[j]; index=j; &#125; &#125; vis[index]=true; sum+=minn; for(int j=0;j&lt;n;j++)&#123; if(!vis[j]&amp;&amp;dist[j]&gt;G[index][j])&#123; dist[j]=G[index][j]; &#125; &#125; &#125; return sum;&#125;int main()&#123; cout&lt;&lt;prime(0)&lt;&lt;endl; return 0;&#125; Kruskal板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 1e3+10;#define LL long long#define INF 0x3f3f3f3fstruct edge&#123; int u,v,cost;&#125;edge[maxn];int pre[maxn];int n,m;//顶点个数，边的个数void upset()&#123; for(int i=1;i&lt;=n;i++) pre[i]=i;&#125;int Find(int x)&#123; int r=x; while(r!=pre[r])&#123; r=pre[r]; &#125; int i=x,j; while(pre[i]!=r)&#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;void mix(int u,int v)&#123; int fu=Find(u),fv=Find(v); pre[fu]=fv;&#125;bool cmp(struct edge a,struct edge b)&#123; return a.cost&lt;=b.cost;&#125;int Kruskal()&#123; int sum=0;//生成树的权值 int cnt=0;//选用边的个数 upset(); for(int i=0;i&lt;m;i++)&#123; int u=edge[i].u; int v=edge[i].v; if(Find(u)!=Find(v))&#123; sum+=edge[i].cost; cnt++; mix(u,v); &#125; if(cnt&gt;=n-1) break; &#125; return sum;&#125;int main()&#123; int u,v,w; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); edge[i].u=u,edge[i].v=v,edge[i].cost=w; &#125; sort(edge,edge+m,cmp); printf("%d\n",Kruskal()); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile简介]]></title>
    <url>%2F2019%2F10%2F05%2FMakefile%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Makefile 简介Makefile 是和 make 命令一起配合使用的.很多大型项目的编译都是通过 Makefile 来组织的, 如果没有 Makefile, 那很多项目中各种库和代码之间的依赖关系不知会多复杂.Makefile的组织流程的能力如此之强, 不仅可以用来编译项目, 还可以用来组织我们平时的一些日常操作. 这个需要大家发挥自己的想象力. Makefile 主要的 5个部分 (显示规则, 隐晦规则, 变量定义, 文件指示, 注释)Makefile基本格式如下: 1234target ... : prerequisites ... command ... ... 其中, target - 目标文件, 可以是 Object File, 也可以是可执行文件prerequisites - 生成 target 所需要的文件或者目标command - make需要执行的命令 (任意的shell命令), Makefile中的命令必须以 [tab] 开头 显示规则 :: 说明如何生成一个或多个目标文件(包括 生成的文件, 文件的依赖文件, 生成的命令)隐晦规则 :: make的自动推导功能所执行的规则变量定义 :: Makefile中定义的变量文件指示 :: Makefile中引用其他Makefile; 指定Makefile中有效部分; 定义一个多行命令注释 :: Makefile只有行注释 “#”, 如果要使用或者输出”#”字符, 需要进行转义, “#“ GNU make 的工作方式读入主Makefile (主Makefile中可以引用其他Makefile)读入被include的其他Makefile初始化文件中的变量推导隐晦规则, 并分析所有规则为所有的目标文件创建依赖关系链根据依赖关系, 决定哪些目标要重新生成执行生成命令 Makefile 初级语法 Makefile 规则 规则语法规则主要有2部分: 依赖关系 和 生成目标的方法. 语法有以下2种: 123target ... : prerequisites ... command ... 或者 123target ... : prerequisites ; command command ... 注 command太长, 可以用 “&quot; 作为换行符 规则中的通配符 :: 表示任意一个或多个字符? :: 表示任意一个字符[…] :: ex. [abcd] 表示a,b,c,d中任意一个字符, [^abcd]表示除a,b,c,d以外的字符, [0-9]表示 0~9中任意一个数字~ :: 表示用户的home目录 路径搜索当一个Makefile中涉及到大量源文件时(这些源文件和Makefile极有可能不在同一个目录中), 这时, 最好将源文件的路径明确在Makefile中, 便于编译时查找. Makefile中有个特殊的变量 VPATH 就是完成这个功能的. 指定了 VPATH 之后, 如果当前目录中没有找到相应文件或依赖的文件, Makefile 回到 VPATH 指定的路径中再去查找.. VPATH 使用方法: vpath &lt;directories&gt; :: 当前目录中找不到文件时, 就从中搜索 vpath &lt;pattern&gt; &lt;directories&gt; :: 符合格式的文件, 就从中搜索 vpath &lt;pattern&gt; :: 清除符合格式的文件搜索路径 vpath :: 清除所有已经设置好的文件路径 复制代码 示例1 - 当前目录中找不到文件时, 按顺序从 src目录 ../parent-dir目录中查找文件1VPATH src:../parent-dir 示例2 - .h结尾的文件都从 ./header 目录中查找1VPATH %.h ./header 示例3 - 清除示例2中设置的规则1VPATH %.h 示例4 - 清除所有VPATH的设置1VPATH Makefile 中的变量 变量定义 ( = or := ) 12OBJS = programA.o programB.oOBJS-ADD = $(OBJS) programC.o 或者 12OBJS := programA.o programB.oOBJS-ADD := $(OBJS) programC.o 其中 = 和 := 的区别在于, := 只能使用前面定义好的变量, = 可以使用后面定义的变量 Makefile内容12OBJS2 = $(OBJS1) programC.oOBJS1 = programA.o programB.o 12all: @echo $(OBJS2) bash中执行 make, 可以看出虽然 OBJS1 是在 OBJS2 之后定义的, 但在 OBJS2中可以提前使用12$ makeprogramA.o programB.o programC.o Makefile内容12OBJS2 := $(OBJS1) programC.oOBJS1 := programA.o programB.o 12all: @echo $(OBJS2) bash中执行 make, 可以看出 OBJS2 中的 $(OBJS1) 为空12$ makeprogramC.o 变量替换Makefile内容 12SRCS := programA.c programB.c programC.cOBJS := $(SRCS:%.c=%.o) 123all: @echo "SRCS: " $(SRCS) @echo "OBJS: " $(OBJS) bash中运行make123$ makeSRCS: programA.c programB.c programC.cOBJS: programA.o programB.o programC.o 变量追加值 += Makefile内容12SRCS := programA.c programB.c programC.cSRCS += programD.c 12all: @echo "SRCS: " $(SRCS) bash中运行make12$ makeSRCS: programA.c programB.c programC.c programD.c 变量覆盖 override作用是使 Makefile中定义的变量能够覆盖 make 命令参数中指定的变量 语法: 123override &lt;variable&gt; = &lt;value&gt;override &lt;variable&gt; := &lt;value&gt;override &lt;variable&gt; += &lt;value&gt; 下面通过一个例子体会 override 的作用： Makefile内容 (没有用override)1234SRCS := programA.c programB.c programC.call: @echo "SRCS: " $(SRCS) bash中运行make12$ make SRCS=nothingSRCS: nothing Makefile内容 (用override)1override SRCS := programA.c programB.c programC.c all: @echo “SRCS: “ $(SRCS) bash中运行make12$ make SRCS=nothingSRCS: programA.c programB.c programC.c 目标变量作用是使变量的作用域仅限于这个目标(target), 而不像之前例子中定义的变量, 对整个Makefile都有效. 语法: 12&lt;target ...&gt; :: &lt;variable-assignment&gt;&lt;target ...&gt; :: override &lt;variable-assignment&gt; (override作用参见 变量覆盖的介绍) Makefile 内容12345678910SRCS := programA.c programB.c programC.ctarget1: TARGET1-SRCS := programD.ctarget1: @echo "SRCS: " $(SRCS) @echo "SRCS: " $(TARGET1-SRCS)target2: @echo "SRCS: " $(SRCS) @echo "SRCS: " $(TARGET1-SRCS) bash中执行make1234567$ make target1SRCS: programA.c programB.c programC.cSRCS: programD.c$ make target2 &lt;-- target2中显示不了 $(TARGET1-SRCS)SRCS: programA.c programB.c programC.cSRCS: Makefile 命令前缀Makefile 中书写shell命令时可以加2种前缀 @ 和 -, 或者不用前缀. 3种格式的shell命令区别如下: 不用前缀 :: 输出执行的命令以及命令执行的结果, 出错的话停止执行前缀 @ :: 只输出命令执行的结果, 出错的话停止执行前缀 - :: 命令执行有错的话, 忽略错误, 继续执行 Makefile 内容 (不用前缀)1234all: echo "没有前缀" cat this_file_not_exist echo "错误之后的命令" &lt;-- 这条命令不会被执行 bash中执行 make$ makeecho “没有前缀” &lt;– 命令本身显示出来没有前缀 &lt;– 命令执行结果显示出来cat this_file_not_existcat: this_file_not_exist: No such file or directorymake: *** [all] Error 1 ########################################################### Makefile 内容 (前缀 @)all: @echo “没有前缀” @cat this_file_not_exist @echo “错误之后的命令” &lt;– 这条命令不会被执行 bash中执行 make$ make没有前缀 &lt;– 只有命令执行的结果, 不显示命令本身cat: this_file_not_exist: No such file or directorymake: *** [all] Error 1 ########################################################### Makefile 内容 (前缀 -)all: -echo “没有前缀” -cat this_file_not_exist -echo “错误之后的命令” &lt;– 这条命令会被执行 bash中执行 make$ makeecho “没有前缀” &lt;– 命令本身显示出来没有前缀 &lt;– 命令执行结果显示出来cat this_file_not_existcat: this_file_not_exist: No such file or directorymake: [all] Error 1 (ignored)echo “错误之后的命令” &lt;– 出错之后的命令也会显示错误之后的命令 &lt;– 出错之后的命令也会执行复制代码 2.4 伪目标伪目标并不是一个”目标(target)”, 不像真正的目标那样会生成一个目标文件. 典型的伪目标是 Makefile 中用来清理编译过程中中间文件的 clean 伪目标, 一般格式如下: .PHONY: clean &lt;– 这句没有也行, 但是最好加上clean: -rm -f *.o 2.5 引用其他的 Makefile语法: include (filename 可以包含通配符和路径) 示例: 复制代码 Makefile 内容all: @echo “主 Makefile begin” @make other-all @echo “主 Makefile end” include ./other/Makefile ./other/Makefile 内容other-all: @echo “other makefile begin” @echo “other makefile end” bash中执行 make$ lltotal 20K-rw-r–r– 1 wangyubin wangyubin 125 Sep 23 16:13 Makefile-rw-r–r– 1 wangyubin wangyubin 11K Sep 23 16:15 makefile.org &lt;– 这个文件不用管drwxr-xr-x 2 wangyubin wangyubin 4.0K Sep 23 16:11 other$ ll other/total 4.0K-rw-r–r– 1 wangyubin wangyubin 71 Sep 23 16:11 Makefile $ make主 Makefile beginmake[1]: Entering directory /path/to/test/makefile&#39; other makefile begin other makefile end make[1]: Leaving directory/path/to/test/makefile’主 Makefile end复制代码 2.6 查看C文件的依赖关系写 Makefile 的时候, 需要确定每个目标的依赖关系. GNU提供一个机制可以查看C代码文件依赖那些文件, 这样我们在写 Makefile 目标的时候就不用打开C源码来看其依赖那些文件了. 比如, 下面命令显示内核源码中 virt/kvm/kvm_main.c 中的依赖关系 $ cd virt/kvm/$ gcc -MM kvm_main.ckvm_main.o: kvm_main.c iodev.h coalesced_mmio.h async_pf.h &lt;– 这句就可以加到 Makefile 中作为编译 kvm_main.o 的依赖关系 2.7 make 退出码Makefile的退出码有以下3种： 0 :: 表示成功执行1 :: 表示make命令出现了错误2 :: 使用了 “-q” 选项, 并且make使得一些目标不需要更新 2.8 指定 Makefile， 指定特定目标默认执行 make 命令时, GNU make在当前目录下依次搜索下面3个文件 “GNUmakefile”, “makefile”, “Makefile”, 找到对应文件之后, 就开始执行此文件中的第一个目标(target). 如果找不到这3个文件就报错. 非默认情况下, 可以在 make 命令中指定特定的 Makefile 和特定的 目标. 示例： 复制代码 Makefile文件名改为 MyMake, 内容target1: @echo “target [1] begin” @echo “target [1] end” target2: @echo “target [2] begin” @echo “target [2] end” bash 中执行 make$ lsMakefile$ mv Makefile MyMake$ lsMyMake$ make &lt;– 找不到默认的 Makefilemake: *** No targets specified and no makefile found. Stop.$ make -f MyMake &lt;– 指定特定的Makefiletarget [1] begintarget [1] end$ make -f MyMake target2 &lt;– 指定特定的目标(target)target [2] begintarget [2] end复制代码 2.9 make 参数介绍make 的参数有很多, 可以通过 make -h 去查看, 下面只介绍几个我认为比较有用的. 参数 含义 –debug[=] 输出make的调试信息, options 可以是 a, b, v-j –jobs 同时运行的命令的个数, 也就是多线程执行 Makefile-r –no-builtin-rules 禁止使用任何隐含规则-R –no-builtin-variabes 禁止使用任何作用于变量上的隐含规则-B –always-make 假设所有目标都有更新, 即强制重编译 2.10 Makefile 隐含规则这里只列一个和编译C相关的. 编译C时，.o 的目标会自动推导为 .c 复制代码 Makefile 中main : main.o gcc -o main main.o #会自动变为:main : main.o gcc -o main main.o main.o: main.c &lt;– main.o 这个目标是隐含生成的 gcc -c main.c复制代码 2.11 隐含规则中的 命令变量 和 命令参数变量2.11.1 命令变量, 书写Makefile可以直接写 shell时用这些变量.下面只列出一些C相关的 变量名 含义 RM rm -fAR arCC ccCXX g++示例: 复制代码 Makefile 内容all: @echo $(RM) @echo $(AR) @echo $(CC) @echo $(CXX) bash 中执行make, 显示各个变量的值$ makerm -farccg++复制代码 2.11.2 命令参数变量变量名 含义 ARFLAGS AR命令的参数CFLAGS C语言编译器的参数CXXFLAGS C++语言编译器的参数 示例: 下面以 CFLAGS 为例演示 复制代码 test.c 内容#include &lt;stdio.h&gt; int main(int argc, char *argv[]){ printf (“Hello Makefile\n”); return 0;} Makefile 内容test: test.o $(CC) -o test test.o bash 中用 make 来测试$ lltotal 24K-rw-r–r– 1 wangyubin wangyubin 69 Sep 23 17:31 Makefile-rw-r–r– 1 wangyubin wangyubin 14K Sep 23 19:51 makefile.org &lt;– 请忽略这个文件-rw-r–r– 1 wangyubin wangyubin 392 Sep 23 17:31 test.c $ makecc -c -o test.o test.ccc -o test test.o &lt;– 这个是自动推导的 $ rm -f test test.o $ make CFLAGS=-Wall &lt;– 命令中加的编译器参数自动追加入下面的编译中了cc -Wall -c -o test.o test.ccc -o test test.o复制代码 2.12 自动变量Makefile 中很多时候通过自动变量来简化书写, 各个自动变量的含义如下: 自动变量 含义 $@ 目标集合$% 当目标是函数库文件时, 表示其中的目标文件名$&lt; 第一个依赖目标. 如果依赖目标是多个, 逐个表示依赖目标$? 比目标新的依赖目标的集合$^ 所有依赖目标的集合, 会去除重复的依赖目标$+ 所有依赖目标的集合, 不会去除重复的依赖目标$* 这个是GNU make特有的, 其它的make不一定支持 Makefile 高级语法 1 嵌套Makefile在 Makefile 初级语法中已经提到过引用其它 Makefile的方法. 这里有另一种写法, 并且可以向引用的其它 Makefile 传递参数. 示例: (不传递参数, 只是调用子文件夹 other 中的Makefile) 复制代码 Makefile 内容all: @echo “主 Makefile begin” @cd ./other &amp;&amp; make @echo “主 Makefile end” ./other/Makefile 内容other-all: @echo “other makefile begin” @echo “other makefile end” bash中执行 make$ lltotal 28K-rw-r–r– 1 wangyubin wangyubin 104 Sep 23 20:43 Makefile-rw-r–r– 1 wangyubin wangyubin 17K Sep 23 20:44 makefile.org &lt;– 这个文件不用管drwxr-xr-x 2 wangyubin wangyubin 4.0K Sep 23 20:42 other$ ll other/total 4.0K-rw-r–r– 1 wangyubin wangyubin 71 Sep 23 16:11 Makefile $ make主 Makefile beginmake[1]: Entering directory /path/to/test/makefile/other&#39; other makefile begin other makefile end make[1]: Leaving directory/path/to/test/makefile/other’主 Makefile end复制代码 示例: (用export传递参数) 复制代码 Makefile 内容export VALUE1 := export.c &lt;– 用了 export, 此变量能够传递到 ./other/Makefile 中VALUE2 := no-export.c &lt;– 此变量不能传递到 ./other/Makefile 中 all: @echo “主 Makefile begin” @cd ./other &amp;&amp; make @echo “主 Makefile end” ./other/Makefile 内容other-all: @echo “other makefile begin” @echo “VALUE1: “ $(VALUE1) @echo “VALUE2: “ $(VALUE2) @echo “other makefile end” bash中执行 make$ make主 Makefile beginmake[1]: Entering directory /path/to/test/makefile/other&#39; other makefile begin VALUE1: export.c &lt;-- VALUE1 传递成功 VALUE2: &lt;-- VALUE2 传递失败 other makefile end make[1]: Leaving directory/path/to/test/makefile/other’主 Makefile end复制代码 补充 export 语法格式如下: export variable = valueexport variable := valueexport variable += value 3.2 定义命令包命令包有点像是个函数, 将连续的相同的命令合成一条, 减少 Makefile 中的代码量, 便于以后维护. 语法: define command…endef 示例: 复制代码 Makefile 内容define run-hello-makefile@echo -n “Hello”@echo “ Makefile!”@echo “这里可以执行多条 Shell 命令!”endef all: $(run-hello-makefile) bash 中运行make$ makeHello Makefile!这里可以执行多条 Shell 命令!复制代码 3.3 条件判断条件判断的关键字主要有 ifeq ifneq ifdef ifndef 语法: 复制代码endif 或者 else endif 复制代码 示例: ifeq的例子, ifneq和ifeq的使用方法类似, 就是取反 复制代码 Makefile 内容all:ifeq (“aa”, “bb”) @echo “equal”else @echo “not equal”endif bash 中执行 make$ makenot equal复制代码 示例: ifdef的例子, ifndef和ifdef的使用方法类似, 就是取反 复制代码 Makefile 内容SRCS := program.c all:ifdef SRCS @echo $(SRCS)else @echo “no SRCS”endif bash 中执行 make$ makeprogram.c复制代码 3.4 Makefile 中的函数Makefile 中自带了一些函数, 利用这些函数可以简化 Makefile 的编写. 函数调用语法如下: $( ) 或者${ } 是函数名 是函数参数 3.4.1 字符串函数字符串替换函数: $(subst ,,) 功能: 把字符串 中的 替换为 返回: 替换过的字符串 复制代码 Makefile 内容all: @echo $(subst t,e,maktfilt) &lt;– 将t替换为e bash 中执行 make$ makemakefile复制代码 模式字符串替换函数: $(patsubst ,,) 功能: 查找中的单词(单词以”空格”, “tab”, “换行”来分割) 是否符合 , 符合的话, 用 替代. 返回: 替换过的字符串 复制代码 Makefile 内容all: @echo $(patsubst %.c,%.o,programA.c programB.c) bash 中执行 make$ makeprogramA.o programB.o复制代码 去空格函数: $(strip ) 功能: 去掉 字符串中开头和结尾的空字符 返回: 被去掉空格的字符串值 复制代码 Makefile 内容VAL := “ aa bb cc “ all: @echo “去除空格前: “ $(VAL) @echo “去除空格后: “ $(strip $(VAL)) bash 中执行 make$ make去除空格前: aa bb cc去除空格后: aa bb cc复制代码 查找字符串函数: $(findstring ,) 功能: 在字符串 中查找 字符串 返回: 如果找到, 返回 字符串, 否则返回空字符串 复制代码 Makefile 内容VAL := “ aa bb cc “ all: @echo $(findstring aa,$(VAL)) @echo $(findstring ab,$(VAL)) bash 中执行 make$ makeaa复制代码 过滤函数: $(filter &lt;pattern…&gt;,) 功能: 以 模式过滤字符串 , 保留 符合模式 的单词, 可以有多个模式 返回: 符合模式 的字符串 复制代码 Makefile 内容all: @echo $(filter %.o %.a,program.c program.o program.a) bash 中执行 make$ makeprogram.o program.a复制代码 反过滤函数: $(filter-out &lt;pattern…&gt;,) 功能: 以 模式过滤字符串 , 去除 符合模式 的单词, 可以有多个模式 返回: 不符合模式 的字符串 复制代码 Makefile 内容all: @echo $(filter-out %.o %.a,program.c program.o program.a) bash 中执行 make$ makeprogram.c复制代码 排序函数: $(sort ) 功能: 给字符串 中的单词排序 (升序) 返回: 排序后的字符串 复制代码 Makefile 内容all: @echo $(sort bac abc acb cab) bash 中执行 make$ makeabc acb bac cab复制代码 取单词函数: $(word ,) 功能: 取字符串 中的 第个单词 (n从1开始) 返回: 中的第个单词, 如果 比 中单词个数要大, 则返回空字符串 复制代码 Makefile 内容all: @echo $(word 1,aa bb cc dd) @echo $(word 5,aa bb cc dd) @echo $(word 4,aa bb cc dd) bash 中执行 make$ makeaa dd复制代码 取单词串函数: $(wordlist ,,) 功能: 从字符串中取从开始到的单词串. 和是一个数字. 返回: 从到的字符串 复制代码 Makefile 内容all: @echo $(wordlist 1,3,aa bb cc dd) @echo $(word 5,6,aa bb cc dd) @echo $(word 2,5,aa bb cc dd) bash 中执行 make$ makeaa bb cc bb复制代码 单词个数统计函数: $(words ) 功能: 统计字符串 中单词的个数 返回: 单词个数 复制代码 Makefile 内容all: @echo $(words aa bb cc dd) @echo $(words aabbccdd) @echo $(words ) bash 中执行 make$ make410复制代码 首单词函数: $(firstword ) 功能: 取字符串 中的第一个单词 返回: 字符串 中的第一个单词 复制代码 Makefile 内容all: @echo $(firstword aa bb cc dd) @echo $(firstword aabbccdd) @echo $(firstword ) bash 中执行 make$ makeaaaabbccdd复制代码 3.4.2 文件名函数取目录函数: $(dir &lt;names…&gt;) 功能: 从文件名序列 中取出目录部分 返回: 文件名序列 中的目录部分 复制代码 Makefile 内容all: @echo $(dir /home/a.c ./bb.c ../c.c d.c) bash 中执行 make$ make/home/ ./ ../ ./复制代码 取文件函数: $(notdir &lt;names…&gt;) 功能: 从文件名序列 中取出非目录部分 返回: 文件名序列 中的非目录部分 复制代码 Makefile 内容all: @echo $(notdir /home/a.c ./bb.c ../c.c d.c) bash 中执行 make$ makea.c bb.c c.c d.c复制代码 取后缀函数: $(suffix &lt;names…&gt;) 功能: 从文件名序列 中取出各个文件名的后缀 返回: 文件名序列 中各个文件名的后缀, 没有后缀则返回空字符串 复制代码 Makefile 内容all: @echo $(suffix /home/a.c ./b.o ../c.a d) bash 中执行 make$ make.c .o .a复制代码 取前缀函数: $(basename &lt;names…&gt;) 功能: 从文件名序列 中取出各个文件名的前缀 返回: 文件名序列 中各个文件名的前缀, 没有前缀则返回空字符串 复制代码 Makefile 内容all: @echo $(basename /home/a.c ./b.o ../c.a /home/.d .e) bash 中执行 make$ make/home/a ./b ../c /home/复制代码 加后缀函数: $(addsuffix ,&lt;names…&gt;) 功能: 把后缀 加到 中的每个单词后面 返回: 加过后缀的文件名序列 复制代码 Makefile 内容all: @echo $(addsuffix .c,/home/a b ./c.o ../d.c) bash 中执行 make$ make/home/a.c b.c ./c.o.c ../d.c.c复制代码 加前缀函数: $(addprefix ,&lt;names…&gt;) 功能: 把前缀 加到 中的每个单词前面 返回: 加过前缀的文件名序列 复制代码 Makefile 内容all: @echo $(addprefix test_,/home/a.c b.c ./d.c) bash 中执行 make$ maketest_/home/a.c test_b.c test_./d.c复制代码 连接函数: $(join ,) 功能: 中对应的单词加到 后面 返回: 连接后的字符串 复制代码 Makefile 内容all: @echo $(join a b c d,1 2 3 4) @echo $(join a b c d,1 2 3 4 5) @echo $(join a b c d e,1 2 3 4) bash 中执行 make$ makea1 b2 c3 d4a1 b2 c3 d4 5a1 b2 c3 d4 e复制代码 3.4.3 foreach语法: $(foreach ,,) 示例: 复制代码 Makefile 内容targets := a b c dobjects := $(foreach i,$(targets),$(i).o) all: @echo $(targets) @echo $(objects) bash 中执行 make$ makea b c da.o b.o c.o d.o复制代码 3.4.4 if这里的if是个函数, 和前面的条件判断不一样, 前面的条件判断属于Makefile的关键字 语法: $(if ,) $(if ,,) 示例: 复制代码 Makefile 内容val := aobjects := $(if $(val),$(val).o,nothing)no-objects := $(if $(no-val),$(val).o,nothing) all: @echo $(objects) @echo $(no-objects) bash 中执行 make$ makea.onothing复制代码 3.4.5 call - 创建新的参数化函数语法: $(call ,,,…) 示例: 复制代码 Makefile 内容log = “====debug====” $(1) “====end====” all: @echo $(call log,”正在 Make”) bash 中执行 make$ make====debug==== 正在 Make ====end====复制代码 3.4.6 origin - 判断变量的来源语法: $(origin ) 返回值有如下类型: 类型 含义 undefined 没有定义过default 是个默认的定义, 比如 CC 变量environment 是个环境变量, 并且 make时没有使用 -e 参数file 定义在Makefile中command line 定义在命令行中override 被 override 重新定义过automatic 是自动化变量 示例: 复制代码 Makefile 内容val-in-file := test-fileoverride val-override := test-override all: @echo $(origin not-define) # not-define 没有定义 @echo $(origin CC) # CC 是Makefile默认定义的变量 @echo $(origin PATH) # PATH 是 bash 环境变量 @echo $(origin val-in-file) # 此Makefile中定义的变量 @echo $(origin val-in-cmd) # 这个变量会加在 make 的参数中 @echo $(origin val-override) # 此Makefile中定义的override变量 @echo $(origin @) # 自动变量, 具体前面的介绍 bash 中执行 make$ make val-in-cmd=val-cmdundefineddefaultenvironmentfilecommand lineoverrideautomatic复制代码 3.4.7 shell语法: $(shell ) 它的作用就是执行一个shell命令, 并将shell命令的结果作为函数的返回. 作用和 &lt;shell command&gt; 一样, ` 是反引号 3.4.8 make 控制函数产生一个致命错误: $(error &lt;text …&gt;) 功能: 输出错误信息, 停止Makefile的运行 复制代码 Makefile 内容all: $(error there is an error!) @echo “这里不会执行!” bash 中执行 make$ makeMakefile:2: *** there is an error!. Stop.复制代码 输出警告: $(warning &lt;text …&gt;) 功能: 输出警告信息, Makefile继续运行 复制代码 Makefile 内容all: $(warning there is an warning!) @echo “这里会执行!” bash 中执行 make$ makeMakefile:2: there is an warning!这里会执行!复制代码 3.5 Makefile中一些GNU约定俗成的伪目标如果有过在Linux上, 从源码安装软件的经历的话, 就会对 make clean, make install 比较熟悉. 像 clean, install 这些伪目标, 广为人知 下面列举一些常用的伪目标, 如果在自己项目的Makefile合理使用这些伪目标的话, 可以让我们自己的Makefile看起来更专业, 呵呵 :) 含义 all 所有目标的目标，其功能一般是编译所有的目标clean 删除所有被make创建的文件install 安装已编译好的程序，其实就是把目标可执行文件拷贝到指定的目录中去print 列出改变过的源文件tar 把源程序打包备份. 也就是一个tar文件dist 创建一个压缩文件, 一般是把tar文件压成Z文件. 或是gz文件TAGS 更新所有的目标, 以备完整地重编译使用check 或 test 一般用来测试makefile的流程]]></content>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LIS]]></title>
    <url>%2F2019%2F09%2F29%2FLIS%2F</url>
    <content type="text"><![CDATA[LIS n^2 dp 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 40005;int a[maxn];int dp[maxn];int main()&#123; int n; scanf("%d",&amp;n); for( int i=0; i&lt;n; i++ )&#123; scanf("%d",a+i); &#125; int ans=0; for( int i=0; i&lt;n; i++ )&#123; dp[i]=1; for( int j=0; j&lt;i; j++ )&#123; if(a[j]&lt;a[i])&#123; dp[i]=max(dp[i],dp[j]+1); &#125; &#125; ans=max(ans,dp[i]); &#125; printf("%d",ans); return 0;&#125; nlogn 二分LIS的nlogn的优化：LIS的优化说白了其实是贪心算法，比如说让你求一个最长上升子序列把，一起走一遍。 比如说（4, 2, 3, 1, 2，3，5）这个序列，求他的最长上升子序列，那么来看，如果求最长的上升序列，那么按照贪心，应该最可能的让该序列的元素整体变小，以便可以加入更多的元素。现在开辟一个新的数组，arr[ 10 ]， { …….} –&gt; 这个是他的空间 ，现在开始模拟贪心算法求解最长上升子序列，第一个数是4，先加进去，那么为{ 4 }再来看下一个数2，它比4小，所以如果他与4替换是不是可以让目前子序列（他这一个元素组成的子序列）变得更小，更方便以后元素的加入呢？是的。所以现在为{ 2 } 再来看他的下一个元素3，他要比2大，所以呢加在他的后面，{ 2, 3}再看下一个元素是1，它比3要小，所以呢为了保证子序列整体尽可能的小（以便可以加入更多的元素），从目前的序列中查找出第一个比他大的数替换掉，那么就变成了{ 1， 3}，继续。。 下一个数是2，那么序列变为{ 1，2}，再下一个数为3，那么序列为{1，2，3}，在下一个数为5，那么序列为{1，2，3，5}，完。 目前序列里又4个元素，所以他的最长子序列的个数为4，但是这个序列是一个伪序列，里面的元素，并不是真正的最长上升子序列，而仅仅和最长上升子序列的个数一样。因为查找的时候用的二分查找，所以时间复杂度为o（nlogn）。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int arr[500],n,dp[500]; scanf("%d",&amp;n); for( int i=1; i&lt;=n; i++ )&#123; scanf("%d",&amp;arr[i]); &#125; int k=1; dp[k]=arr[1]; for( int i=2; i&lt;=n; i++ )&#123; if(arr[i]&gt;dp[k]) dp[++k]=arr[i]; else *lower_bound(dp+1,dp+1+k,arr[i])=arr[i]; &#125; printf("%d\n",k); return 0;&#125;]]></content>
      <tags>
        <tag>算法之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方舟编译器编译及其执行]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%96%B9%E8%88%9F%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[华为开发者相关网站 华为鸿蒙系统开发者论坛 华为开发者联盟 方舟编译器 华为 DevEco Studio 华为开源平台 华为云 华为应用市场 方舟编译器编译 环境准备 开发环境推荐您需要安装一个64位版本的Ubuntu（推荐Ubuntu 16.04） 12sudo apt-get -y install openjdk-8-jdk git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip lib32z1-dev qemu g++-multilib gcc-multilib libglib2.0-dev libpixman-1-dev linux-libc-dev:i386sudo apt-get -y install gcc-5-aarch64-linux-gnu g++-5-aarch64-linux-gnu 安装Clang编译器并完成配置（用于编译方舟编译器代码）下载clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04LLVM下载地址：LLVM放置到openarkcompiler/tools目录，打开openarkcompiler/build/config/BUILDCONFIG.gn文件，将GN_C_COMPILER、GN_CXX_COMPILER和GN_AR_COMPILER三个变量配置为Clang编译器所在路径，例如： 123GN_C_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang&quot;GN_CXX_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/clang++&quot;GN_AR_COMPILER = &quot;$&#123;MAPLE_ROOT&#125;/tools/clang_llvm-8.0.0-x86_64-linux-gnu-ubuntu-16.04/bin/llvm-ar&quot; 其中${MAPLE_ROOT}为openarkcompiler源码根目录。 安装Ninja、GN并完成配置下载Ninja(v1.9.0)及GN(Linux Version)Ninja下载地址：NinjaGN下载地址：gn将GN和Ninja可执行程序放置到openarkcompiler/tools目录，打开openarkcompiler/Makefile文件，将GN和NINJA两个变量配置为GN和Ninja可执行程序所在路径。例如：12GN := $&#123;MAPLE_ROOT&#125;/tools/gn/gnNINJA := $&#123;MAPLE_ROOT&#125;/tools/ninja_1.9.0/ninja 编译器编译 源码下载下载地址：源码可以通过Clone or Download的方式下载openarkcompiler 源码注：默认源码下载目录为openarkcompiler源码编译在openarkcompiler目录下执行以下命令，编译出OpenArkCompiler，默认输出路径 openarkcompiler/out/bin。 12source build/envsetup.shmake 命令说明：source build/envsetup.sh 初始化环境，将OpenArkCompiler工具链路径openarkcompiler/src/bin设置到环境变量中make 编译OpenArkCompiler的Release版本make BUILD_TYPE=DEBUG 编译OpenArkCompiler的Debug版本 编译结果展示 方舟编译器执行过程 在博主跑helloworld的过程中，发现抱错显示少java-core.jar包，在几经周折后在码云上找到了jar包,java-core.jar地址. 在openarkcompiler文件夹下新建文件夹libjava-core，将jar包拷贝至目录下 在openarkcompiler目录下执行 1source build/envsetup.sh cd 至samples文件夹下的helloworld 执行 1make 执行其他samples样例如图所示（在执行过程中找了一个杨辉三角的java代码，跑了一下)]]></content>
      <tags>
        <tag>方舟编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH,公钥,私钥的理解]]></title>
    <url>%2F2019%2F09%2F25%2FSSH-%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先我们需要区分加密和认证这两个基本概念。 加密是将数据资料加密，使得非法用户即使取得加密过的资料，也无法获取正确的资料内容，所以数据加密可以保护数据，防止监听攻击。其重点在于数据的安全性。身份认证是用来判断某个身份的真实性，确认身份后，系统才可以依不同的身份给予不同的权限。其重点在于用户的真实性。两者的侧重点是不同的。 公钥和私钥其次我们还要了解公钥和私钥的概念和作用。 在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是非对称密钥密码系统，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。 公钥私钥的原则：一个公钥对应一个私钥。密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 非对称密钥密码的主要应用就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的，下面我就详细讲解一下两者的区别。 基于公开密钥的加密过程 比如有两个用户Alice和Bob，Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下： Bob将他的公开密钥传送给Alice。 Alice用Bob的公开密钥加密她的消息，然后传送给Bob。 Bob用他的私人密钥解密Alice的消息。 上面的过程可以用下图表示，Alice使用Bob的公钥进行加密，Bob用自己的私钥进行解密。 基于公开密钥的认证过程 身份认证和加密就不同了，主要用户鉴别用户的真伪。这里我们只要能够鉴别一个用户的私钥是正确的，就可以鉴别这个用户的真伪。 还是Alice和Bob这两个用户，Alice想让Bob知道自己是真实的Alice，而不是假冒的，因此Alice只要使用公钥密码学对文件签名发送给Bob，Bob使用Alice的公钥对文件进行解密，如果可以解密成功，则证明Alice的私钥是正确的，因而就完成了对Alice的身份鉴别。整个身份认证的过程如下： Alice用她的私人密钥对文件加密，从而对文件签名。 Alice将签名的文件传送给Bob。 Bob用Alice的公钥解密文件，从而验证签名。 上面的过程可以用下图表示，Alice使用自己的私钥加密，Bob用Alice的公钥进行解密。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地项目恢复]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[今天在从本地仓库推送到github的过程中由于操作不当，导致本地代码被覆盖。瞬间泪崩。一度以为自己写了好几天的代码就断送了。不过一想到git是分布式的，本身就是因为版本控制而开发的呀，所以一定有办法恢复以前版本。方法如下： 查看以往版本号git reflog 找到想要恢复的版本号(黄色)git reset --hard 版本号]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地仓库更新至github]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%9B%B4%E6%96%B0%E8%87%B3github%2F</url>
    <content type="text"><![CDATA[git本地仓库更新至github 右键需要更新的项目 git add .(注意这里有一个空格) git commit -m &quot;更新信息&quot; git remote rm origin &#39;git remote add origin ssh或者HTTPS地址 git push -u origin master/mastercpp 如果推送不成功的话，肯能是本地项目缺少README.md文件，在保证安全的情况下，可以考虑强推 git push -f origin master/mastercpp]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
